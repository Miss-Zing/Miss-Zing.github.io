<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="学习," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="面试记录算法岗地平线面试记录 手推反向传播（求导） 编程题两道 画菱形（递归） 最长对称字串   opencv用过吗？resize的插值方式。 Linux下遍历文件夹下的png文件 python怎么遍历文件夹下的所有png文件 SSD怎么回归位置的？ SSD和YOLO的区别 SSD相对YOLO其中容易被忽视的一点: 去掉了YOLO的fc，纯CNN，所以可对任意大小的图片进行识别。 ssd 有mu">
<meta name="keywords" content="学习">
<meta property="og:type" content="article">
<meta property="og:title" content="一切为了offer">
<meta property="og:url" content="http://yoursite.com/2018/10/08/job/index.html">
<meta property="og:site_name" content="My Heart">
<meta property="og:description" content="面试记录算法岗地平线面试记录 手推反向传播（求导） 编程题两道 画菱形（递归） 最长对称字串   opencv用过吗？resize的插值方式。 Linux下遍历文件夹下的png文件 python怎么遍历文件夹下的所有png文件 SSD怎么回归位置的？ SSD和YOLO的区别 SSD相对YOLO其中容易被忽视的一点: 去掉了YOLO的fc，纯CNN，所以可对任意大小的图片进行识别。 ssd 有mu">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://omwiezyrk.bkt.clouddn.com/blog/20180807/220059792.png">
<meta property="og:image" content="http://omwiezyrk.bkt.clouddn.com/blog/20180807/220153555.png">
<meta property="og:image" content="http://omwiezyrk.bkt.clouddn.com/blog/20180807/220202073.png">
<meta property="og:image" content="http://omwiezyrk.bkt.clouddn.com/blog/20180807/220213241.png">
<meta property="og:image" content="http://omwiezyrk.bkt.clouddn.com/blog/20180807/220218822.png">
<meta property="og:image" content="http://omwiezyrk.bkt.clouddn.com/blog/20180904/230338530.png">
<meta property="og:image" content="http://omwiezyrk.bkt.clouddn.com/blog/20180904/230450534.png">
<meta property="og:image" content="http://omwiezyrk.bkt.clouddn.com/blog/20180904/230458375.png">
<meta property="og:updated_time" content="2018-10-13T08:05:27.665Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一切为了offer">
<meta name="twitter:description" content="面试记录算法岗地平线面试记录 手推反向传播（求导） 编程题两道 画菱形（递归） 最长对称字串   opencv用过吗？resize的插值方式。 Linux下遍历文件夹下的png文件 python怎么遍历文件夹下的所有png文件 SSD怎么回归位置的？ SSD和YOLO的区别 SSD相对YOLO其中容易被忽视的一点: 去掉了YOLO的fc，纯CNN，所以可对任意大小的图片进行识别。 ssd 有mu">
<meta name="twitter:image" content="http://omwiezyrk.bkt.clouddn.com/blog/20180807/220059792.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/10/08/job/"/>





  <title>一切为了offer | My Heart</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">My Heart</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Just For Dear Miss Zing.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/08/job/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Doordy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://blog-1251940545-1251940545.cossh.myqcloud.com/133908722.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Heart">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">一切为了offer</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-08T00:00:00+08:00">
                2018-10-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/我们/" itemprop="url" rel="index">
                    <span itemprop="name">我们</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <a id="more"></a>
<h1 id="面试记录"><a href="#面试记录" class="headerlink" title="面试记录"></a>面试记录</h1><h2 id="算法岗"><a href="#算法岗" class="headerlink" title="算法岗"></a>算法岗</h2><h3 id="地平线面试记录"><a href="#地平线面试记录" class="headerlink" title="地平线面试记录"></a>地平线面试记录</h3><ol>
<li>手推反向传播（求导）</li>
<li>编程题两道<ul>
<li>画菱形（递归）</li>
<li>最长对称字串</li>
</ul>
</li>
<li>opencv用过吗？resize的插值方式。</li>
<li>Linux下遍历文件夹下的png文件</li>
<li>python怎么遍历文件夹下的所有png文件</li>
<li>SSD怎么回归位置的？</li>
<li>SSD和YOLO的区别<ul>
<li>SSD相对YOLO其中容易被忽视的一点: 去掉了YOLO的fc，纯CNN，所以可对任意大小的图片进行识别。</li>
<li>ssd 有multi-scale：卷积操作在不同scale的feature maps上；yolo只有single scale。</li>
<li>ssd使用default boxes 加上 various scales/aspect ratios:对不同scale的feature maps，采用不同尺寸和比例的default boxes 变形；这和yolo的anchor boxes是不同的，印象里yolo的anchor boxes不变形。</li>
<li>ssd 没有fc layer，yolo有。</li>
<li>loss不一样，我印象里，yolo还有个object和not object一项，因为yolo需要把一张图片分割成grid cells，只有一个cell包含了某个object的center。但是ssd并不需要分割成grid，没有cell和object的conrrespondence。</li>
</ul>
</li>
<li>精确检索比赛的具体流程</li>
</ol>
<h3 id="虹软面试记录"><a href="#虹软面试记录" class="headerlink" title="虹软面试记录"></a>虹软面试记录</h3><ol>
<li>Adaboost的是怎么确定弱分类器的？（交叉熵）</li>
<li>交叉熵</li>
<li>SSD和YOLO的区别? </li>
<li>类似推导反向求导</li>
<li>矩阵的基础知识。比如秩与解的关系。</li>
</ol>
<h3 id="腾讯算法笔试题型"><a href="#腾讯算法笔试题型" class="headerlink" title="腾讯算法笔试题型"></a>腾讯算法笔试题型</h3><p>单因素方差分析，假设检验<br>方差分析：方差分析就是对试验数据进行分析，检验方差相等的多个正态总体均值是否相等，进而判断各因素对试验指标的影响是否显著</p>
<h3 id="网易深度学习笔试"><a href="#网易深度学习笔试" class="headerlink" title="网易深度学习笔试"></a>网易深度学习笔试</h3><p>SVM,Faster RCNN，LOSS</p>
<h2 id="开发岗"><a href="#开发岗" class="headerlink" title="开发岗"></a>开发岗</h2><h3 id="拼多多"><a href="#拼多多" class="headerlink" title="拼多多"></a>拼多多</h3><ol>
<li>进程、线程和协程的区别<ol>
<li>概念<ul>
<li>进程：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</li>
<li>线程：线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</li>
<li>协程:协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</li>
</ul>
</li>
<li>区别：</li>
</ol>
</li>
</ol>
<p><strong>进程多与线程比较：</strong><br>线程是指进程内的一个执行单元,也是进程内的可调度实体。线程与进程的区别:</p>
<ol>
<li><p>地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间</p>
</li>
<li><p>资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源</p>
</li>
<li><p>线程是处理器调度的基本单位,但进程不是</p>
</li>
<li><p>二者均可并发执行</p>
</li>
<li><p>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制</p>
</li>
</ol>
<p><strong>协程多与线程进行比较”</strong></p>
<ol>
<li><p>一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。</p>
</li>
<li><p>线程进程都是同步机制，而协程则是异步</p>
</li>
<li><p>协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态</p>
</li>
<li>TCP的滑动窗口</li>
<li>为什么要三次握手</li>
<li>为什么要用虚函数</li>
<li>介绍一下STL</li>
<li>说说c++11的新特性<ul>
<li><a href="https://blog.csdn.net/FX677588/article/details/70157088" target="_blank" rel="noopener">https://blog.csdn.net/FX677588/article/details/70157088</a></li>
<li><a href="https://my.oschina.net/wangxuanyihaha/blog/183151" target="_blank" rel="noopener">https://my.oschina.net/wangxuanyihaha/blog/183151</a></li>
<li><a href="https://coolshell.cn/articles/5265.html" target="_blank" rel="noopener">https://coolshell.cn/articles/5265.html</a></li>
</ul>
</li>
<li>编程：硬币组合问题</li>
<li>编程：给出给个节点的id和其父节点的id,构建一个多叉树</li>
<li>本来想问数据库的没问</li>
</ol>
<h3 id="360面试"><a href="#360面试" class="headerlink" title="360面试"></a>360面试</h3><ol>
<li>线程的通信方式</li>
<li>构造顺序</li>
<li>析构顺序</li>
<li>sizeof(class A)</li>
<li>n+1个整数，都在1~n之间，只有一个重复，怎么做？<ul>
<li>假设第一个是k，可以和第k个换，这样循环，不用额外空间</li>
</ul>
</li>
<li>黑名单实现（域名匹配）</li>
</ol>
<h1 id="C-基础知识"><a href="#C-基础知识" class="headerlink" title="C++基础知识"></a>C++基础知识</h1><h2 id="C-内存空间"><a href="#C-内存空间" class="headerlink" title="C++内存空间"></a>C++内存空间</h2><p>一个C++程序编译以后占用的内存分为如下几个部分：<br><strong>栈：</strong>由编译器自动分配释放，存放函数的参数值，局部变量的值。在一个进程中，位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数的调用。</p>
<p><strong>堆：</strong>由程序员分配和释放，若程序员不释放，则程序结束时被操作系统回收。存放由new、malloc分配的内存，可动态扩展和收缩。</p>
<p><strong>全局区（静态区）：</strong>全局变量和静态变量是存放在一起的，初始化的全局变量和初始化的静态变量在一块区域；未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。</p>
<p><strong>文字常量区：</strong>常量字符串放在这里，程序结束后由操作系统释放。</p>
<p><strong>程序代码区：</strong>存放函数体的二进制代码。</p>
<p>###堆和栈的主要区别</p>
<ol>
<li>管理的方式不同。栈由编译器自动管理，无需手动控制；堆由程序员控制，容易产生内存泄漏。</li>
<li>能否产生碎片。对于堆来说，频繁地new/delete势必造成内存空间的不连续，从而造成大量碎片，使程序效率降低；对于栈来说，不会存在这个问题，因为栈是后进先出的队列，一一对应，不会出现某个内存块从栈中间弹出。</li>
<li>生长方向。对于堆来说，生长方向向上，向着内存地址增加的地方；对于栈，生长方向向下，向着内存地址减小的方向。</li>
<li>分配效率：栈是计算机系统提高的数据结构，操作系统在底层对栈提供支持，分配专门的寄存器存放栈的地址，压栈出栈有专门的指令执行，这就决定了栈的效率比较高。对于堆则是由C/C++函数库提供，显然栈的效率比堆高。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;                     <span class="comment">//全局初始化区</span></span><br><span class="line"><span class="keyword">char</span> *p1;                      <span class="comment">//全局未初始化区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> b;                       <span class="comment">//栈区</span></span><br><span class="line">  <span class="keyword">char</span> s[] = <span class="string">"abc"</span>;            <span class="comment">//栈区</span></span><br><span class="line">  <span class="keyword">char</span> *p2;                    <span class="comment">//栈区</span></span><br><span class="line">  <span class="keyword">char</span> *p3 = <span class="string">"123456"</span>;         <span class="comment">//123456在常量区，指针p3在栈上。</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> c =<span class="number">0</span>；            <span class="comment">//全局（静态）初始化区</span></span><br><span class="line">  p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">  p2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">  <span class="comment">//分配得来得10和20字节的区域就在堆区。</span></span><br><span class="line">  <span class="built_in">strcpy</span>(p1, <span class="string">"123456"</span>);      </span><br><span class="line">  <span class="comment">//123456放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="C-复习记录"><a href="#C-复习记录" class="headerlink" title="C++复习记录"></a>C++复习记录</h2><ol>
<li><p>静态局部变量的作用：保存函数每次执行后的结果，以便下次调用函数时，继续使用上次计算的结果。</p>
</li>
<li><p>宏定义可出现在程序中的任何一行。</p>
</li>
<li><p>宏的作用域：从定义开始到文件结束，或者使用<code>#undef</code>指令终止宏。如果在此区间有包含文件<code>#include</code>指令，那么宏作用域会延伸到被包含的整个文件。</p>
</li>
<li><p>宏定义无须分号结尾，但是如果有不报错。</p>
</li>
<li><p>如果字符串中出现宏名，则不进行宏展开。</p>
</li>
<li><p>有参宏：<code>#define &lt;宏名&gt;(&lt;形参表&gt;) &lt;含形参的字符串&gt;</code></p>
</li>
<li><p>条件编译：</p>
<ul>
<li><p>宏名作为条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef &lt;宏名&gt; </span><br><span class="line">    &lt;程序段&gt;</span><br><span class="line">#else</span><br><span class="line">    &lt;程序段&gt;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
</li>
<li><p>常量表达式作为条件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if &lt;常量表达式&gt; </span><br><span class="line">    &lt;程序段&gt;</span><br><span class="line">#elif &lt;常量表达式&gt;</span><br><span class="line">    &lt;程序段&gt;</span><br><span class="line">#else</span><br><span class="line">    &lt;程序段&gt;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>结构体中的静态变量的值为该结构类型的所有变量共享，访问的时候使用<code>::</code>。</p>
</li>
<li>所有枚举类型的大小都是4字节，即一个int值的大小。</li>
<li><p><code>typedef char str[10];</code>以这种方式给<code>char[10]</code>起别名。</p>
</li>
<li><p><code>const</code>:</p>
<ul>
<li><code>const *</code>：指针指向的内容不能变。</li>
<li><code>* const</code>：指针不能变</li>
<li><code>const * const</code>：都不能变，而且需要初始化</li>
</ul>
</li>
<li><code>new</code>和<code>delete</code>成对使用，<code>delete []&lt;指针变量&gt;</code>：吧所执行的数组元素的内存空间归还。</li>
<li>类的保护成员被自己类的成员函数访问，也能被自己的<strong>派生类</strong>访问。</li>
<li>一个类的对象不能作为自身类的成员，但是自身类的指针可以作为该类的成员。</li>
<li>类不允许对数据成员进行初始化，必须使用构造函数。</li>
<li>类和结构体的区别：<ul>
<li>c++中结构体也可以使用<code>private</code>等关键字</li>
<li>类成员的默认访问权限为<code>private</code>，而结构体成员的默认访问权限为<code>public</code></li>
<li>结构体可以使用花括号进行初始化，但是类只能使用构造函数。</li>
<li>结构体也可以构造函数</li>
</ul>
</li>
<li>如果一个构造函数没有任何形参，或者所有形参都有默认值，这就是一个默认构造函数。</li>
<li>拷贝构造函数：<code>&lt;类名&gt;::&lt;类名&gt;(const &lt;类名&gt; &amp;&lt;对象名&gt;)</code></li>
<li><p><strong>如果一个类中显式的定义了一个拷贝构造函数，而没有其他构造函数，则该类不能创建对象。</strong></p>
</li>
<li><p>用sizeof（类名）得到的大小不包括静态成员。静态成员函数主要用于管理类中的静态数据成员，不能直接访问非静态成员，不能定义为虚函数。</p>
</li>
<li><p>静态成员函数可以被继承，但不能定义为虚函数。</p>
</li>
<li>数据成员的指针：<code>&lt;type&gt;&lt;class name&gt;::*&lt;point name&gt; = &amp;&lt;class name&gt;::&lt;class member name&gt;</code></li>
<li><p>多态：</p>
<ul>
<li>编译时刻的静态多态性：函数重载和运算符重载</li>
<li>运行时刻的动态多态性：继承和虚函数</li>
</ul>
</li>
<li><p>虚基类是为了防止二义性，继承方式为在：之后加上virtual，只能产生一个子对象。</p>
</li>
<li>若不使用虚函数，则调用函数时，是由指针类型决定的；反之是由对象的实际类型决定的。</li>
<li><p>如果一个类含有纯虚函数，那么此类就称为抽象类（接口）。</p>
<p><code>virtual &lt;返回类型&gt; name (&lt;形参表&gt;) = 0</code></p>
</li>
<li>运算符重载：形参数比运算符目数少一个</li>
<li><p>友元函数：将类外函数用<code>friend</code>修饰，可以访问类内所有成员。</p>
</li>
<li><p>虚函数不能是静态成员函数，也不能是友元函数。</p>
</li>
<li><p>二级指针可以用来访问二维数组，但不能直接指向一个二维数组。</p>
</li>
<li><p>模板与有参宏的区别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(x,y) ((x)&lt;(y))?(x):(y)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>宏展开时编译器不能检查类型兼容性</li>
<li>若<code>cout&lt;&lt;max(x,++y)</code>，则y会计算两次</li>
<li>宏扩展属于预处理，编译是针对宏扩展之后的代码进行，编译错误只能给出宏扩展之后的代码错误，而不是宏定义自身的错误。</li>
</ul>
</li>
<li><p>重载类型转换函数：<code>operator type()</code></p>
</li>
<li><p>RTTI：运行时类型信息，<code>typeid(&lt;表达式&gt;).name()</code> </p>
</li>
<li><p>explicit 可以有效得防止构造函数的隐式转换带来的错误或者误解<br><a href="https://www.cnblogs.com/cutepig/archive/2009/01/14/1375917.html" target="_blank" rel="noopener">https://www.cnblogs.com/cutepig/archive/2009/01/14/1375917.html</a></p>
</li>
</ol>
<h2 id="C-string的用法和例子"><a href="#C-string的用法和例子" class="headerlink" title="C++ string的用法和例子"></a>C++ string的用法和例子</h2><h3 id="使用场合："><a href="#使用场合：" class="headerlink" title="使用场合："></a>使用场合：</h3><p>string 是 C++ 标准库的一个重要的部分，主要用于字符串处理。可以使用输入输出流方式直接进行操作，也可以通过文件等手段进行操作。同时 C++ 的算法库对 string 也有着很好的支持，而且 string 还和 c 语言的字符串之间有着良好的接口。虽然也有一些弊端，但是瑕不掩瑜。<br>其中使用的代码多数都是来自 cpp 官网，因为例子非常全。</p>
<h3 id="声明和初始化方法："><a href="#声明和初始化方法：" class="headerlink" title="声明和初始化方法："></a><strong>声明和初始化方法：</strong></h3><p>想使用 string 首先要在头文件当中加入 <string><br>声明方式也很简单</string></p>
<h4 id="声明："><a href="#声明：" class="headerlink" title="声明："></a>声明：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s;//声明一个string 对象</span><br><span class="line">string ss[10];//声明一个string对象的数组</span><br></pre></td></tr></table></figure>
<h4 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h4><p>使用等号的初始化叫做拷贝初始化，不使用等号的初始化叫做直接初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    string s;//默认初始化，一个空字符串</span><br><span class="line">    string s1(&quot;ssss&quot;);//s1是字面值“ssss”的副本</span><br><span class="line">    string s2(s1);//s2是s1的副本</span><br><span class="line">    string s3=s2;//s3是s2的副本</span><br><span class="line">    string s4(10,&apos;c&apos;);//把s4初始化</span><br><span class="line">    string s5=&quot;hiya&quot;;//拷贝初始化</span><br><span class="line">    string s6=string(10,&apos;c&apos;);//拷贝初始化，生成一个初始化好的对象，拷贝给s6</span><br><span class="line"></span><br><span class="line">    //string s(cp,n)</span><br><span class="line">    char cs[]=&quot;12345&quot;;</span><br><span class="line">    string s7(cs,3);//复制字符串cs的前3个字符到s当中</span><br><span class="line"></span><br><span class="line">    //string s(s2,pos2)</span><br><span class="line">    string s8=&quot;asac&quot;;</span><br><span class="line">    string s9(s8,2);//从s2的第二个字符开始拷贝，不能超过s2的size</span><br><span class="line"></span><br><span class="line">    //string s(s2,pos2,len2)</span><br><span class="line">    string s10=&quot;qweqweqweq&quot;;</span><br><span class="line">    string s11(s10,3,4);//s4是s3从下标3开始4个字符的拷贝，超过s3.size出现未定义</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串处理："><a href="#字符串处理：" class="headerlink" title="字符串处理："></a><strong>字符串处理：</strong></h3><h4 id="substr-操作："><a href="#substr-操作：" class="headerlink" title="substr 操作："></a><strong>substr 操作：</strong></h4><p>注意 substr 没有迭代器作为参数的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    string s=&quot;abcdefg&quot;;</span><br><span class="line"></span><br><span class="line">    //s.substr(pos1,n)返回字符串位置为pos1后面的n个字符组成的串</span><br><span class="line">    string s2=s.substr(1,5);//bcdef</span><br><span class="line"></span><br><span class="line">    //s.substr(pos)//得到一个pos到结尾的串</span><br><span class="line">    string s3=s.substr(4);//efg</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果输入的位置超过字符的长度，会抛出一个 out_of_range 的异常</p>
<h4 id="insert-操作"><a href="#insert-操作" class="headerlink" title="insert 操作:"></a><strong>insert 操作:</strong></h4><p>代码来自 cpp 官网，经过自己的整理<br>注意用迭代器当参数和无符号数当参数的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    string str=&quot;to be question&quot;;</span><br><span class="line">    string str2=&quot;the &quot;;</span><br><span class="line">    string str3=&quot;or not to be&quot;;</span><br><span class="line">    string::iterator it;</span><br><span class="line"></span><br><span class="line">    //s.insert(pos,str)//在s的pos位置插入str</span><br><span class="line">    str.insert(6,str2);                 // to be the question</span><br><span class="line"></span><br><span class="line">    //s.insert(pos,str,a,n)在s的pos位置插入str中插入位置a到后面的n个字符</span><br><span class="line">    str.insert(6,str3,3,4);             // to be not the question</span><br><span class="line"></span><br><span class="line">    //s.insert(pos,cstr,n)//在pos位置插入cstr字符串从开始到后面的n个字符</span><br><span class="line">    str.insert(10,&quot;that is cool&quot;,8);    // to be not that is the question</span><br><span class="line"></span><br><span class="line">    //s.insert(pos,cstr)在s的pos位置插入cstr</span><br><span class="line">    str.insert(10,&quot;to be &quot;);            // to be not to be that is the question</span><br><span class="line"></span><br><span class="line">    //s.insert(pos,n,ch)在s.pos位置上面插入n个ch</span><br><span class="line">    str.insert(15,1,&apos;:&apos;);               // to be not to be: that is the question</span><br><span class="line"></span><br><span class="line">    //s.insert(s.it,ch)在s的it指向位置前面插入一个字符ch，返回新插入的位置的迭代器</span><br><span class="line">    it = str.insert(str.begin()+5,&apos;,&apos;); // to be, not to be: that is the question</span><br><span class="line"></span><br><span class="line">    //s.insert(s.it,n,ch)//在s的it所指向位置的前面插入n个ch</span><br><span class="line">    str.insert (str.end(),3,&apos;.&apos;);       // to be, not to be: that is the question...</span><br><span class="line"></span><br><span class="line">    //s.insert(it,str.ita,str.itb)在it所指向的位置的前面插入[ita,itb)的字符串</span><br><span class="line">    str.insert (it+2,str3.begin(),str3.begin()+3); // to be, or not to be: that is the question...</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="erase-操作："><a href="#erase-操作：" class="headerlink" title="erase 操作："></a><strong>erase 操作：</strong></h4><p>用来执行删除操作<br>删除操作有三种</p>
<ul>
<li>指定 pos 和 len，其中 pos 为为起始位置，pos 以及后面 len-1 个字符串都删除</li>
<li>迭代器，删除迭代器指向的字符</li>
<li>迭代器范围，删除这一范围的字符串，范围左闭右开</li>
</ul>
<p>代码来自 cpp 官网</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">  std::string str (&quot;This is an example sentence.&quot;);</span><br><span class="line">  std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line">                          // &quot;This is an example sentence.&quot;</span><br><span class="line">  str.erase (10,8);       //            ^^^^^^^^</span><br><span class="line">  //直接指定删除的字符串位置第十个后面的8个字符</span><br><span class="line">  std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line">                            // &quot;This is an sentence.&quot;</span><br><span class="line">  str.erase (str.begin()+9);//           ^</span><br><span class="line">  //删除迭代器指向的字符</span><br><span class="line">  std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line">                            // &quot;This is a sentence.&quot;</span><br><span class="line">                            //       ^^^^^</span><br><span class="line">  str.erase (str.begin()+5, str.end()-9);</span><br><span class="line">  //删除迭代器范围的字符</span><br><span class="line">  std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line">                            // &quot;This sentence.&quot;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="append-和-replace-操作"><a href="#append-和-replace-操作" class="headerlink" title="append 和 replace 操作:"></a><strong>append 和 replace 操作:</strong></h4><p>append 函数可以用来在字符串的末尾追加字符和字符串。由于 string 重载了运算符，也可以用 += 操作实现<br>repalce 顾名思义，就是替换的意思，先删除，后增加。<br>代码来自 cpp 官网，附上自己的解释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    std::string str;</span><br><span class="line">    std::string str2=&quot;Writing &quot;;</span><br><span class="line">    std::string str3=&quot;print 10 and then 5 more&quot;;</span><br><span class="line"></span><br><span class="line">    //直接追加一个str2的字符串</span><br><span class="line">    str.append(str2);                       // &quot;Writing &quot;</span><br><span class="line">    //后面追加str3第6个字符开始的3个字符串</span><br><span class="line">    str.append(str3,6,3);                   // &quot;10 &quot;</span><br><span class="line">    //追加字符串形参的前5个字符</span><br><span class="line">    str.append(&quot;dots are cool&quot;,5);          // &quot;dots &quot;</span><br><span class="line">    //直接添加</span><br><span class="line">    str.append(&quot;here: &quot;);                   // &quot;here: &quot;</span><br><span class="line">    //添加10个&apos;.&apos;</span><br><span class="line">    str.append(10u,&apos;.&apos;);                    // &quot;..........&quot;</span><br><span class="line">    //添加str3迭代器范围的字符串</span><br><span class="line">    str.append(str3.begin()+8,str3.end());  // &quot; and then 5 more&quot;</span><br><span class="line">    //最后这个比较特殊，意思是添加5个&apos;A&apos;，实际上参数里面的65对应的asc码就是65</span><br><span class="line">    str.append&lt;int&gt;(5,65);                // &quot;.....&quot;</span><br><span class="line">    //字符串追加也可以用重载运算符实现</span><br><span class="line">    str+=&quot;lalala&quot;;</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>replace 的使用方法，replace 支持使用无符号整数寻找位置，也支持用迭代器寻找位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    std::string base=&quot;this is a test string.&quot;;</span><br><span class="line">    std::string str2=&quot;n example&quot;;</span><br><span class="line">    std::string str3=&quot;sample phrase&quot;;</span><br><span class="line">    std::string str4=&quot;useful.&quot;;</span><br><span class="line"></span><br><span class="line">    // replace signatures used in the same order as described above:</span><br><span class="line"></span><br><span class="line">    // Using positions:                 0123456789*123456789*12345</span><br><span class="line">    std::string str=base;           // &quot;this is a test string.&quot;</span><br><span class="line">    //第9个字符以及后面的4个字符被str2代替</span><br><span class="line">    str.replace(9,5,str2);          // &quot;this is an example string.&quot; (1)</span><br><span class="line">    //第19个字符串以及后面的5个字符用str的第7个字符以及后面的5个字符代替</span><br><span class="line">    str.replace(19,6,str3,7,6);     // &quot;this is an example phrase.&quot; (2)</span><br><span class="line">    //第8个字符以及后面的9个字符用字符串参数代替</span><br><span class="line">    str.replace(8,10,&quot;just a&quot;);     // &quot;this is just a phrase.&quot;     (3)</span><br><span class="line">    //第8个字符以及后面的5个字符用字符串参数的前7个字符替换</span><br><span class="line">    str.replace(8,6,&quot;a shorty&quot;,7);  // &quot;this is a short phrase.&quot;    (4)</span><br><span class="line">    //第22以及后面的0个字符用3个叹号替换</span><br><span class="line">    str.replace(22,1,3,&apos;!&apos;);        // &quot;this is a short phrase!!!&quot;  (5)</span><br><span class="line">    //迭代器的原理同上</span><br><span class="line">    // Using iterators:                                               0123456789*123456789*</span><br><span class="line">    str.replace(str.begin(),str.end()-3,str3);                    // &quot;sample phrase!!!&quot;      (1)</span><br><span class="line">    str.replace(str.begin(),str.begin()+6,&quot;replace&quot;);             // &quot;replace phrase!!!&quot;     (3)</span><br><span class="line">    str.replace(str.begin()+8,str.begin()+14,&quot;is coolness&quot;,7);    // &quot;replace is cool!!!&quot;    (4)</span><br><span class="line">    str.replace(str.begin()+12,str.end()-4,4,&apos;o&apos;);                // &quot;replace is cooool!!!&quot;  (5)</span><br><span class="line">    str.replace(str.begin()+11,str.end(),str4.begin(),str4.end());// &quot;replace is useful.&quot;    (6)</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;   </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的 replace 操作可以用 insert 和 erase 的操作组合替换，但是 replace 操作更加方便。</p>
<p><strong>assign 操作：</strong><br>assign 操作在一起列容器当中都存在，比如 vector 等等。是一个很基本的操作函数，string 使用 assign 可以灵活的对其进行赋值。<br>代码来自 cpp 官网</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    std::string str;</span><br><span class="line">    std::string base=&quot;The quick brown fox jumps over a lazy dog.&quot;;</span><br><span class="line"></span><br><span class="line">    // used in the same order as described above:</span><br><span class="line">    //直接把base赋值给str</span><br><span class="line">    str.assign(base);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    //把base第10个字符以及后面的8个字符赋给str</span><br><span class="line">    str.assign(base,10,9);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;         // &quot;brown fox&quot;</span><br><span class="line">    //把参数中的0到6个字符串赋给str</span><br><span class="line">    str.assign(&quot;pangrams are cool&quot;,7);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;         // &quot;pangram&quot;</span><br><span class="line">    //直接使用参数赋值</span><br><span class="line">    str.assign(&quot;c-string&quot;);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;         // &quot;c-string&quot;</span><br><span class="line">    //给str赋值10个&apos;*&apos;字符</span><br><span class="line">    str.assign(10,&apos;*&apos;);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;         // &quot;**********&quot;</span><br><span class="line">    //赋值是10个&apos;-&apos;</span><br><span class="line">    str.assign&lt;int&gt;(10,0x2D);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;         // &quot;----------&quot;</span><br><span class="line">    //指定base迭代器范围的字符串</span><br><span class="line">    str.assign(base.begin()+16,base.end()-12);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;         // &quot;fox jumps over&quot;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="string-的搜索操作"><a href="#string-的搜索操作" class="headerlink" title="string 的搜索操作:"></a><strong>string 的搜索操作:</strong></h3><p>string 类中提供了很多性能优秀，使用方便的成员方法。而且在泛型算法当中也有很多实用的技巧。</p>
<h4 id="find-和-rfind-函数"><a href="#find-和-rfind-函数" class="headerlink" title="find 和 rfind 函数:"></a><strong>find 和 rfind 函数:</strong></h4><p>find 函数主要是查找一个字符串是否在调用的字符串中出现过，大小写敏感。<br>代码来自 cpp 官网</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    std::string str (&quot;There are two needles in this haystack with needles.&quot;);</span><br><span class="line">    std::string str2 (&quot;needle&quot;);</span><br><span class="line"></span><br><span class="line">    // different member versions of find in the same order as above:</span><br><span class="line">    //在str当中查找第一个出现的needle，找到则返回出现的位置，否则返回结尾</span><br><span class="line">    std::size_t found = str.find(str2);</span><br><span class="line">    if (found!=std::string::npos)</span><br><span class="line">    std::cout &lt;&lt; &quot;first &apos;needle&apos; found at: &quot; &lt;&lt; found &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    //在str当中，从第found+1的位置开始查找参数字符串的前6个字符</span><br><span class="line">    found=str.find(&quot;needles are small&quot;,found+1,6);</span><br><span class="line">    if (found!=std::string::npos)</span><br><span class="line">    std::cout &lt;&lt; &quot;second &apos;needle&apos; found at: &quot; &lt;&lt; found &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    //在str当中查找参数中的字符串</span><br><span class="line">    found=str.find(&quot;haystack&quot;);</span><br><span class="line">    if (found!=std::string::npos)</span><br><span class="line">    std::cout &lt;&lt; &quot;&apos;haystack&apos; also found at: &quot; &lt;&lt; found &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    //查找一个字符</span><br><span class="line">    found=str.find(&apos;.&apos;);</span><br><span class="line">    if (found!=std::string::npos)</span><br><span class="line">    std::cout &lt;&lt; &quot;Period found at: &quot; &lt;&lt; found &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    //组合使用，把str2用参数表中的字符串代替</span><br><span class="line">    // let&apos;s replace the first needle:</span><br><span class="line">    str.replace(str.find(str2),str2.length(),&quot;preposition&quot;);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rfind 函数就是找最后一个出现的匹配字符串，返回的位置仍然是从前往后数的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    std::string str (&quot;The sixth sick sheik&apos;s sixth sheep&apos;s sick.&quot;);</span><br><span class="line">    std::string key (&quot;sixth&quot;);//                    ^</span><br><span class="line">    //rfind是找最后一个出现的匹配字符串</span><br><span class="line">    std::size_t found = str.rfind(key);</span><br><span class="line">    if (found!=std::string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;found&lt;&lt;endl;//输出23</span><br><span class="line">        str.replace (found,key.length(),&quot;seventh&quot;);//找到的sixth替换成seventh</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找的效率非常高，我没看过 stl 源码剖析，但是感觉是用 kmp 实现的。呵呵，可以自己写一个。</p>
<h4 id="find-…-of-函数"><a href="#find-…-of-函数" class="headerlink" title="find_….of 函数:"></a><strong>find_….of 函数:</strong></h4><ul>
<li>find_first_of(args) <strong>查找 args 中任何一个字符第一次出现的位置</strong></li>
<li>find_last_of(args) <strong>最后一个出现的位置</strong></li>
<li>find_fist_not_of(args) <strong>查找第一个不在 args 中的字符</strong></li>
<li>find_last_not_of <strong>查找最后一个不在 args 中出现的字符</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    std::string str1 (&quot;Please, replace the vowels in this sentence by asterisks.&quot;);</span><br><span class="line">    std::size_t found1 = str1.find_first_of(&quot;aeiou&quot;);</span><br><span class="line">    //把所有元音找出来用*代替</span><br><span class="line">    while (found1!=std::string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        str1[found1]=&apos;*&apos;;</span><br><span class="line">        found1=str1.find_first_of(&quot;aeiou&quot;,found1+1);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; str1 &lt;&lt; &apos;\n&apos;;</span><br><span class="line"></span><br><span class="line">    //在str2中找到第一个不是消协英文字母和空格的字符</span><br><span class="line">    std::string str2 (&quot;look for non-alphabetic characters...&quot;);</span><br><span class="line">    std::size_t found2 = str2.find_first_not_of(&quot;abcdefghijklmnopqrstuvwxyz &quot;);</span><br><span class="line">    if (found2!=std::string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;The first non-alphabetic character is &quot; &lt;&lt; str2[found2];</span><br><span class="line">        std::cout &lt;&lt; &quot; at position &quot; &lt;&lt; found2 &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>find_last_of 和 find_last_not_of 与 first 基本相同，就不写例子代码了。</p>
<h3 id="比较与转换"><a href="#比较与转换" class="headerlink" title="比较与转换:"></a><strong>比较与转换:</strong></h3><p>类似 c 语言的字符串比较函数 strcmp 函数一样，支持字符串比较操作，同时也类似 python、C# 语言中的函数一样，支持把数字和字符串转换。有些特性是 C++11 当中才有。<br><strong><em>注意编译器 bug：</em></strong><br>在 MinGW 编译器当中如果版本低于 3.8，虽然支持 c++11 但是里面有一个 bug，就是不支持字符串和数组的转换！要更新 MinGW 的版本才可以，或者直接使用 g++。</p>
<h4 id="compare-函数"><a href="#compare-函数" class="headerlink" title="compare 函数:"></a><strong>compare 函数:</strong></h4><p>和 strcmp 函数一样，如果两个字符串相等，那么返回 0，调用对象大于参数返回 1，小于返回 - 1。<br>在 compare 当中还支持部分比较，里面有 6 个参数可以设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    string s1=&quot;123&quot;,s2=&quot;123&quot;;</span><br><span class="line">    cout&lt;&lt;s1.compare(s2)&lt;&lt;endl;//0</span><br><span class="line"></span><br><span class="line">    s1=&quot;123&quot;,s2=&quot;1234&quot;;</span><br><span class="line">    cout&lt;&lt;s1.compare(s2)&lt;&lt;endl;//-1</span><br><span class="line"></span><br><span class="line">    s1=&quot;1234&quot;,s2=&quot;123&quot;;</span><br><span class="line">    cout&lt;&lt;s1.compare(s2)&lt;&lt;endl;//1</span><br><span class="line"></span><br><span class="line">    std::string str1 (&quot;green apple&quot;);</span><br><span class="line">    std::string str2 (&quot;red apple&quot;);</span><br><span class="line"></span><br><span class="line">    if (str1.compare(str2) != 0)</span><br><span class="line">    std::cout &lt;&lt; str1 &lt;&lt; &quot; is not &quot; &lt;&lt; str2 &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    //str1的第6个字符以及后面的4个字符和参数比较</span><br><span class="line">    if (str1.compare(6,5,&quot;apple&quot;) == 0)</span><br><span class="line">    std::cout &lt;&lt; &quot;still, &quot; &lt;&lt; str1 &lt;&lt; &quot; is an apple\n&quot;;</span><br><span class="line"></span><br><span class="line">    if (str2.compare(str2.size()-5,5,&quot;apple&quot;) == 0)</span><br><span class="line">    std::cout &lt;&lt; &quot;and &quot; &lt;&lt; str2 &lt;&lt; &quot; is also an apple\n&quot;;</span><br><span class="line">    //str1的第6个字符以及后面的4个字符和str2的第4个字符以及后面的4个字符比较</span><br><span class="line">    if (str1.compare(6,5,str2,4,5) == 0)</span><br><span class="line">    std::cout &lt;&lt; &quot;therefore, both are apples\n&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 string 重载了运算符，可以直接用 &gt;,&lt;，== 来进行比较，也很方便。</p>
<h4 id="数值转换："><a href="#数值转换：" class="headerlink" title="数值转换："></a><strong>数值转换：</strong></h4><p>在 io 的部分有过数值和字符串相互转换的例子，使用的是 stringstream 函数，在 c++11 当中有定义好的现成的函数取调用，非常方便。</p>
<table>
<thead>
<tr>
<th>string 和数值转换</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td>to_string(val)</td>
<td style="text-align:center">把 val 转换成 string</td>
</tr>
<tr>
<td>stoi(s,p,b)</td>
<td style="text-align:center">把字符串 s 从 p 开始转换成 b 进制的 int</td>
</tr>
<tr>
<td>stol(s,p,b)</td>
<td style="text-align:center">long</td>
</tr>
<tr>
<td>stoul(s,p,b)</td>
<td style="text-align:center">unsigned long</td>
</tr>
<tr>
<td>stoll(s,p,b)</td>
<td style="text-align:center">long long</td>
</tr>
<tr>
<td>stoull(s,p,b)</td>
<td style="text-align:center">unsigned long long</td>
</tr>
<tr>
<td>stof(s,p)</td>
<td style="text-align:center">float</td>
</tr>
<tr>
<td>stod(s,p)</td>
<td style="text-align:center">double</td>
</tr>
<tr>
<td>stold(s,p)</td>
<td style="text-align:center">long double</td>
</tr>
</tbody>
</table>
<p>// 注意，下段代码在 MinGw 中会报错！即使使用 c++11 编译也一样，无法识别 to_string！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    string s1;</span><br><span class="line">    s1=to_string(100);</span><br><span class="line">    cout&lt;&lt;s1&lt;&lt;endl;</span><br><span class="line">    int a=stoi(s1,0,10)+1;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><ul>
<li>解决hash冲突的几种方式</li>
<li><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="TCP-IP-网络编程-——-理论基础"><a href="#TCP-IP-网络编程-——-理论基础" class="headerlink" title="TCP/IP 网络编程 —— 理论基础"></a>TCP/IP 网络编程 —— 理论基础</h2></li>
</ul>
<h3 id="1、OSI-模型"><a href="#1、OSI-模型" class="headerlink" title="1、OSI 模型"></a>1、OSI 模型</h3><p><img src="http://omwiezyrk.bkt.clouddn.com/blog/20180807/220059792.png" alt="mark"></p>
<h3 id="2、TCP-IP-协议的四个层次"><a href="#2、TCP-IP-协议的四个层次" class="headerlink" title="2、TCP/IP 协议的四个层次"></a>2、TCP/IP 协议的四个层次</h3><p>TCP/IP 协议的体系结构分为四层，这四层由高到低分别是：应用层、传输层、网络层（网际层）和链路层（网络接口层）。<br><img src="http://omwiezyrk.bkt.clouddn.com/blog/20180807/220153555.png" alt="mark"></p>
<p>（1）链路层</p>
<p>链路层在 TCP/IP 协议栈的最低层，也称为数据链路层或网络接口层，通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。链路层的功能是把接收到的网络层数据报 (也称 IP 数据报) 通过该层的物理接口发送到传输介质上，或从物理网络上接收数据帧，抽出 IP 数据报并交给 IP 层。 </p>
<p>（2）网络层 (Network Layer)<br>网络层也称为互联网层，由于该层的主要协议是 IP 协议，因而也可简称为 IP 层。它是 TCP/IP 协议栈中最重要的一层，主要功能是可以把源主机上的分组发送到互联网中的任何一台目标主机上。</p>
<p>（3）传输层 (Transport Layer)<br>我们通常所说的两台主机之间的通信其实是两台主机上对应应用程序之间的通信，传输层提供的就是应用程序之间的通信，也叫端到端 (End to End) 的通信。在 TCP/IP 协议族中传输层包含两个不同的传输协议：一个是 TCP(传输控制协议)；另一个是 UDP(用户数据报协议)。<br>（4）应用层 (Application Layer)<br>应用层向使用网络的用户提供特定的、常用的应用程序，如使用最广泛的远程登录 (Telnet)、文件传输协议(FTP)、超文本传输协议(HTTP)、域名系统(DNS)、简单网络管理协议(SNMP) 和简单邮件传输协议 (SMTP) 等。要注意有些应用层协议是基于 TCP 协议的(如 FTP 和 HTTP 等)，有些应用层协议是基于 UDP 协议的(如 SNMP 等)。</p>
<p>TCP/IP 协议分为四层结构，这四层结构中有两个重要的边界：一个是将操作系统与应用程序分开的边界，另一个是将高层互联网地址与低层物理网卡地址分开的边界。</p>
<p><img src="http://omwiezyrk.bkt.clouddn.com/blog/20180807/220202073.png" alt="mark"></p>
<ul>
<li>操作系统边界</li>
</ul>
<p>操作系统边界的上面是应用层，应用层处理的是用户应用程序 (用户进程) 的细节问题，提供面向用户的服务。 </p>
<ul>
<li>地址边界</li>
</ul>
<p>地址边界的上层为网络层，网络层用于对不同的网络进行互联，连接在一起的所有网络为了能互相寻址，要使用统一的互联网地址 (IP 地址)。 </p>
<p>3、通信模型<br><img src="http://omwiezyrk.bkt.clouddn.com/blog/20180807/220213241.png" alt="mark"></p>
<p>4、数据封装与解封过程<br><img src="http://omwiezyrk.bkt.clouddn.com/blog/20180807/220218822.png" alt="mark"></p>
<h3 id="传输层协议TCP和UDP"><a href="#传输层协议TCP和UDP" class="headerlink" title="传输层协议TCP和UDP"></a>传输层协议TCP和UDP</h3><p>这里只讨论使用TCP协议的网络编程，由于UDP的不可靠性，现在使用的越来越少，但是为了和TCP做对比，这里还是稍微提一下概念。</p>
<h4 id="用户数据报协议（UDP）"><a href="#用户数据报协议（UDP）" class="headerlink" title="用户数据报协议（UDP）"></a>用户数据报协议（UDP）</h4><p>UDP是一个简单的、无连接、不可靠的传输层协议，应用进程往一个UDP套接字写入一个消息，该消息随后被封装到一个UDP数据报，该UDP数据报进而被封装到一个IP数据报，然后发完目的地。UDP不保证UDP数据报会到达最终目的地，不保证各个数据报达到目的地的先后顺序，也不保证每个数据报只到达一次。<br>​ 每个UDP数据报后有一个长度，在数据报正确到达目的地后，长度会随数据传递给应用程序，所以通常情况下在应用程序看来，UDP每次接收到的都是与发送的大小一致的数据包，而TCP是一个字节流协议，传输的数据是没有边界的。</p>
<p>​ 下图显示的是UDP的首部，从中可以看出，UDP其实就是在IP的基础上多提供的了一个端口，可以实现通过端口来将数据传送给特定的进程。</p>
<h4 id="传输控制协议（TCP）"><a href="#传输控制协议（TCP）" class="headerlink" title="传输控制协议（TCP）"></a>传输控制协议（TCP）</h4><p>TCP提供了面向连接的，靠性的服务，与UDP相比，它具有确认、超时重传、流量控制、拥塞控制等机制。</p>
<p>在两端进行通信前必须先建立连接，当TCP向另一端发送数据时，将启动一个定时器，它要求对端返回一个确认，如果在定时器超时后还没有收到确认，TCP就自动重传数据并等待更长时间。在数次重传失败后TCP才放弃。<br>​ 当TCP接收到另一端TCP发来的数据后，将发送一个确认，这个确认不一定是立即发送的，通常将在推迟一段时候后发送（延时确认机制）。</p>
<p>​ TCP将保持她首部和数据的校验和，这是一个端到端的校验和，目的是检验数据在传输过程中的任何变化，如果收到端的校验和有差错，TCP将丢弃这个报文段并发送确认，等待发送端超时重传。</p>
<p>​ TCP并不保证数据一定会被对端接收,因为这是不可能做到的,如果有可能，TCP就将数据递送到对端，否则就通知用户。因此，TCP也不能被描述成是100%可靠的协议，它提供的是数据的可靠递送货故障的可靠通知。</p>
<p>​ TCP含有用于动态估算客户和服务器之间的往返时间(round-trip time, RTT)的算法,以便它知道等待一个确认需要多长时间。</p>
<p>​ TCP通过给其中的每个字节关联一个序列号对所发送的数据进行排序。若接收端接收到的数据非顺序到达,接收端TCP将先根据它们的序列化重新排序，再把结果数据传递给接收应用。若接收到了重复数据，它将根据序列号判定数据是重复的,从而丢弃重复数据。</p>
<p>​ TCP总是告知对端在任何时刻它一次能够从对端接收多少字节的数据,这称为通知窗口，在任何时刻，该窗口指出接收缓冲区当前可用的空间量,从而确保发送端发送的数据不会使接收缓冲区溢出。</p>
<h5 id="TCP服务端编程的一般步骤为："><a href="#TCP服务端编程的一般步骤为：" class="headerlink" title="TCP服务端编程的一般步骤为："></a>TCP服务端编程的一般步骤为：</h5><ol>
<li>调用socket函数，创建一个套接字描述符。</li>
<li>创建网络地址结构，指定要监听的IP和端口号。</li>
<li>调用bind函数，将套接字描述符与网络地址结构绑定。</li>
<li>调用listen函数，将套接字描述符转为监听套接字，表示该描述符是用于从指定地址和端口接收连接的。</li>
<li>调用accept函数来获取链接。</li>
<li>得到连接后使用read和write函数完描述符里读写数据。</li>
<li>完成后调用close关闭描述符。</li>
</ol>
<h5 id="TCP客户端端编程的一般步骤为："><a href="#TCP客户端端编程的一般步骤为：" class="headerlink" title="TCP客户端端编程的一般步骤为："></a>TCP客户端端编程的一般步骤为：</h5><ol>
<li>调用socket函数，创建一个套接字描述符。</li>
<li>创建网络地址结构，指定要连接的服务端的IP和端口号。</li>
<li>调用connect函数连接服务端。</li>
<li>连接成功后调用read、write函数读写数据</li>
<li>完成后调用close关闭描述符。</li>
</ol>
<h1 id="其他问题汇总"><a href="#其他问题汇总" class="headerlink" title="其他问题汇总"></a>其他问题汇总</h1><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一陪。具体来说，红黑树是满足如下条件的二叉查找树（binary search tree）：</p>
<ol>
<li>每个节点要么是红色，要么是黑色。</li>
<li>根节点必须是黑色，每个叶子节点（NIL）是黑色</li>
<li>红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）。</li>
<li>对于每个节点，从该点至null（树尾端）的任何路径，都含有相同个数的黑色节点。</li>
</ol>
<p>在树的结构发生改变时（插入或者删除操作），往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的条件。</p>
<h2 id="算法类"><a href="#算法类" class="headerlink" title="算法类"></a>算法类</h2><h3 id="生成式模型和判别式模型"><a href="#生成式模型和判别式模型" class="headerlink" title="生成式模型和判别式模型"></a><a href="https://blog.csdn.net/wolenski/article/details/7985426" target="_blank" rel="noopener">生成式模型和判别式模型</a></h3><p><img src="http://omwiezyrk.bkt.clouddn.com/blog/20180904/230338530.png" alt="mark"></p>
<h3 id="卷积的作用"><a href="#卷积的作用" class="headerlink" title="卷积的作用"></a>卷积的作用</h3><p>可以理解为一种混合信息的手段。是一个滤波器，每个卷积核都可以获得不同的信息。</p>
<p><a href="http://www.hankcs.com/ml/understanding-the-convolution-in-deep-learning.html" target="_blank" rel="noopener">理解深度学习中的卷积</a></p>
<h3 id="激活函数的作用"><a href="#激活函数的作用" class="headerlink" title="激活函数的作用"></a>激活函数的作用</h3><p>用来加入非线性因素的，解决线性模型所不能解决的问题。</p>
<ul>
<li>tanh：双切正切函数，取值范围[-1,1]</li>
<li>sigmoid：采用S形函数，取值范围[0,1]</li>
<li>ReLU：简单而粗暴，大于0的留下，否则一律为0</li>
</ul>
<h3 id="池化的功能"><a href="#池化的功能" class="headerlink" title="池化的功能"></a>池化的功能</h3><p>逐步减少输入表征的空间尺寸。特别地，池化</p>
<ul>
<li>使输入表征（特征维度）更小而易操作</li>
<li>减少网络中的参数与计算数量，从而遏制过拟合</li>
<li>增强网络对输入图像中的小变形、扭曲、平移的鲁棒性（输入里的微小扭曲不会改变池化输出——因为我们在局部邻域已经取了最大值/平均值）。</li>
<li>帮助我们获得不因尺寸而改变的等效图片表征。这非常有用，因为这样我们就可以探测到图片里的物体，不论那个物体在哪。</li>
</ul>
<h3 id="ROIPooling-和-ROIAlign"><a href="#ROIPooling-和-ROIAlign" class="headerlink" title="ROIPooling 和 ROIAlign"></a>ROIPooling 和 ROIAlign</h3><p><strong>RoI Pooling</strong></p>
<p>实现从原图ROI区域映射到卷积区域最后pooling到固定大小的功能，然后通过池化把该区域的尺寸归一化成卷积网络输入的尺寸。</p>
<p><strong>ROIAlign</strong></p>
<p>上面RoI Pooling从原图ROI映射到卷积区域，即原图ROI与特征图ROI之间的映射，使用了stride间隔的取整，使得特征图ROI再映射回原图ROI的时候有stride的误差。尤其经过最大值池化后的特征与原ROI之间的空间不对齐就更加明显了。 </p>
<p>因此，ROIAlign从原图到特征图直接的ROI映射直接使用双线性插值，不取整，这样误差会小很多，经过池化后再对应回原图的准确性也更高些。 </p>
<p>这里假设得到的浮点型坐标为(x,y)，取其周围最近的四个点，在Y方向内插两次，再在X方向内插一次，得到新的值。ROI的形状是不变化的。</p>
<h3 id="SVM的理解"><a href="#SVM的理解" class="headerlink" title="SVM的理解"></a>SVM的理解</h3><ul>
<li><p><a href="https://blog.csdn.net/v_july_v/article/details/7624837" target="_blank" rel="noopener">理解svm的三重境界</a></p>
</li>
<li><p><a href="https://my.oschina.net/wangguolongnk/blog/111349?fromerr=lMaxdRMU" target="_blank" rel="noopener">深入理解支持向量机的对偶问题</a></p>
</li>
</ul>
<h3 id="为什么要用L2-loss？"><a href="#为什么要用L2-loss？" class="headerlink" title="为什么要用L2 loss？"></a>为什么要用L2 loss？</h3><p><img src="http://omwiezyrk.bkt.clouddn.com/blog/20180904/230450534.png" alt="mark"><br><img src="http://omwiezyrk.bkt.clouddn.com/blog/20180904/230458375.png" alt="mark"></p>
<h3 id="光流场是什么"><a href="#光流场是什么" class="headerlink" title="光流场是什么"></a>光流场是什么</h3><p>光流场是图片中每个像素都有一个x方向和y方向的位移，所以在上面那些光流计算结束后得到的光流flow是个和原来图像大小相等的双通道图像。</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>宝宝，欢迎投币~嘿嘿</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="http://blog-1251940545-1251940545.cossh.myqcloud.com/135251145.png" alt="Mr.Doordy WeChat Pay"/>
        <p>WeChat Pay</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/学习/" rel="tag"># 学习</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/10/08/dataStucture/" rel="next" title="数据结构复习记录">
                <i class="fa fa-chevron-left"></i> 数据结构复习记录
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://blog-1251940545-1251940545.cossh.myqcloud.com/133908722.jpg"
               alt="Mr.Doordy" />
          <p class="site-author-name" itemprop="name">Mr.Doordy</p>
           
              <p class="site-description motion-element" itemprop="description">愿待你如初，爱你入骨</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/">
                <span class="site-state-item-count">33</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Miss-Zing" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      Github
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://weibo.com/u/2493428177" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      Weibo
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#面试记录"><span class="nav-number">1.</span> <span class="nav-text">面试记录</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#算法岗"><span class="nav-number">1.1.</span> <span class="nav-text">算法岗</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#地平线面试记录"><span class="nav-number">1.1.1.</span> <span class="nav-text">地平线面试记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虹软面试记录"><span class="nav-number">1.1.2.</span> <span class="nav-text">虹软面试记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#腾讯算法笔试题型"><span class="nav-number">1.1.3.</span> <span class="nav-text">腾讯算法笔试题型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网易深度学习笔试"><span class="nav-number">1.1.4.</span> <span class="nav-text">网易深度学习笔试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#开发岗"><span class="nav-number">1.2.</span> <span class="nav-text">开发岗</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#拼多多"><span class="nav-number">1.2.1.</span> <span class="nav-text">拼多多</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#360面试"><span class="nav-number">1.2.2.</span> <span class="nav-text">360面试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-基础知识"><span class="nav-number">2.</span> <span class="nav-text">C++基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-内存空间"><span class="nav-number">2.1.</span> <span class="nav-text">C++内存空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-复习记录"><span class="nav-number">2.2.</span> <span class="nav-text">C++复习记录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-string的用法和例子"><span class="nav-number">2.3.</span> <span class="nav-text">C++ string的用法和例子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用场合："><span class="nav-number">2.3.1.</span> <span class="nav-text">使用场合：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#声明和初始化方法："><span class="nav-number">2.3.2.</span> <span class="nav-text">声明和初始化方法：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#声明："><span class="nav-number">2.3.2.1.</span> <span class="nav-text">声明：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化："><span class="nav-number">2.3.2.2.</span> <span class="nav-text">初始化：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串处理："><span class="nav-number">2.3.3.</span> <span class="nav-text">字符串处理：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#substr-操作："><span class="nav-number">2.3.3.1.</span> <span class="nav-text">substr 操作：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#insert-操作"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">insert 操作:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#erase-操作："><span class="nav-number">2.3.3.3.</span> <span class="nav-text">erase 操作：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#append-和-replace-操作"><span class="nav-number">2.3.3.4.</span> <span class="nav-text">append 和 replace 操作:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string-的搜索操作"><span class="nav-number">2.3.4.</span> <span class="nav-text">string 的搜索操作:</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#find-和-rfind-函数"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">find 和 rfind 函数:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#find-…-of-函数"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">find_….of 函数:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#比较与转换"><span class="nav-number">2.3.5.</span> <span class="nav-text">比较与转换:</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#compare-函数"><span class="nav-number">2.3.5.1.</span> <span class="nav-text">compare 函数:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数值转换："><span class="nav-number">2.3.5.2.</span> <span class="nav-text">数值转换：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据结构"><span class="nav-number">3.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#操作系统"><span class="nav-number">4.</span> <span class="nav-text">操作系统</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#计算机网络"><span class="nav-number">5.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-IP-网络编程-——-理论基础"><span class="nav-number">5.1.</span> <span class="nav-text">TCP/IP 网络编程 —— 理论基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、OSI-模型"><span class="nav-number">5.1.1.</span> <span class="nav-text">1、OSI 模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、TCP-IP-协议的四个层次"><span class="nav-number">5.1.2.</span> <span class="nav-text">2、TCP/IP 协议的四个层次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传输层协议TCP和UDP"><span class="nav-number">5.1.3.</span> <span class="nav-text">传输层协议TCP和UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#用户数据报协议（UDP）"><span class="nav-number">5.1.3.1.</span> <span class="nav-text">用户数据报协议（UDP）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#传输控制协议（TCP）"><span class="nav-number">5.1.3.2.</span> <span class="nav-text">传输控制协议（TCP）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP服务端编程的一般步骤为："><span class="nav-number">5.1.3.2.1.</span> <span class="nav-text">TCP服务端编程的一般步骤为：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP客户端端编程的一般步骤为："><span class="nav-number">5.1.3.2.2.</span> <span class="nav-text">TCP客户端端编程的一般步骤为：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#其他问题汇总"><span class="nav-number">6.</span> <span class="nav-text">其他问题汇总</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#红黑树"><span class="nav-number">6.1.</span> <span class="nav-text">红黑树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法类"><span class="nav-number">6.2.</span> <span class="nav-text">算法类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生成式模型和判别式模型"><span class="nav-number">6.2.1.</span> <span class="nav-text">生成式模型和判别式模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#卷积的作用"><span class="nav-number">6.2.2.</span> <span class="nav-text">卷积的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#激活函数的作用"><span class="nav-number">6.2.3.</span> <span class="nav-text">激活函数的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#池化的功能"><span class="nav-number">6.2.4.</span> <span class="nav-text">池化的功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ROIPooling-和-ROIAlign"><span class="nav-number">6.2.5.</span> <span class="nav-text">ROIPooling 和 ROIAlign</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SVM的理解"><span class="nav-number">6.2.6.</span> <span class="nav-text">SVM的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要用L2-loss？"><span class="nav-number">6.2.7.</span> <span class="nav-text">为什么要用L2 loss？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#光流场是什么"><span class="nav-number">6.2.8.</span> <span class="nav-text">光流场是什么</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.Doordy</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
