<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="愿待你如初，爱你入骨">
<meta property="og:type" content="website">
<meta property="og:title" content="My Heart">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="My Heart">
<meta property="og:description" content="愿待你如初，爱你入骨">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="My Heart">
<meta name="twitter:description" content="愿待你如初，爱你入骨">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>My Heart</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">My Heart</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Just For Dear Miss Zing.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/08/job/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Doordy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://blog-1251940545-1251940545.cossh.myqcloud.com/133908722.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Heart">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/08/job/" itemprop="url">一切为了offer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-08T00:00:00+08:00">
                2018-10-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/我们/" itemprop="url" rel="index">
                    <span itemprop="name">我们</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h1 id="面试记录"><a href="#面试记录" class="headerlink" title="面试记录"></a>面试记录</h1><h2 id="算法岗"><a href="#算法岗" class="headerlink" title="算法岗"></a>算法岗</h2><h3 id="地平线面试记录"><a href="#地平线面试记录" class="headerlink" title="地平线面试记录"></a>地平线面试记录</h3><ol>
<li>手推反向传播（求导）</li>
<li>编程题两道<ul>
<li>画菱形（递归）</li>
<li>最长对称字串</li>
</ul>
</li>
<li>opencv用过吗？resize的插值方式。</li>
<li>Linux下遍历文件夹下的png文件</li>
<li>python怎么遍历文件夹下的所有png文件</li>
<li>SSD怎么回归位置的？</li>
<li>SSD和YOLO的区别<ul>
<li>SSD相对YOLO其中容易被忽视的一点: 去掉了YOLO的fc，纯CNN，所以可对任意大小的图片进行识别。</li>
<li>ssd 有multi-scale：卷积操作在不同scale的feature maps上；yolo只有single scale。</li>
<li>ssd使用default boxes 加上 various scales/aspect ratios:对不同scale的feature maps，采用不同尺寸和比例的default boxes 变形；这和yolo的anchor boxes是不同的，印象里yolo的anchor boxes不变形。</li>
<li>ssd 没有fc layer，yolo有。</li>
<li>loss不一样，我印象里，yolo还有个object和not object一项，因为yolo需要把一张图片分割成grid cells，只有一个cell包含了某个object的center。但是ssd并不需要分割成grid，没有cell和object的conrrespondence。</li>
</ul>
</li>
<li>精确检索比赛的具体流程</li>
</ol>
<h3 id="虹软面试记录"><a href="#虹软面试记录" class="headerlink" title="虹软面试记录"></a>虹软面试记录</h3><ol>
<li>Adaboost的是怎么确定弱分类器的？（交叉熵）</li>
<li>交叉熵</li>
<li>SSD和YOLO的区别? </li>
<li>类似推导反向求导</li>
<li>矩阵的基础知识。比如秩与解的关系。</li>
</ol>
<h3 id="腾讯算法笔试题型"><a href="#腾讯算法笔试题型" class="headerlink" title="腾讯算法笔试题型"></a>腾讯算法笔试题型</h3><p>单因素方差分析，假设检验<br>方差分析：方差分析就是对试验数据进行分析，检验方差相等的多个正态总体均值是否相等，进而判断各因素对试验指标的影响是否显著</p>
<h3 id="网易深度学习笔试"><a href="#网易深度学习笔试" class="headerlink" title="网易深度学习笔试"></a>网易深度学习笔试</h3><p>SVM,Faster RCNN，LOSS</p>
<h2 id="开发岗"><a href="#开发岗" class="headerlink" title="开发岗"></a>开发岗</h2><h3 id="拼多多"><a href="#拼多多" class="headerlink" title="拼多多"></a>拼多多</h3><ol>
<li>进程、线程和协程的区别<ol>
<li>概念<ul>
<li>进程：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</li>
<li>线程：线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</li>
<li>协程:协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</li>
</ul>
</li>
<li>区别：</li>
</ol>
</li>
</ol>
<p><strong>进程多与线程比较：</strong><br>线程是指进程内的一个执行单元,也是进程内的可调度实体。线程与进程的区别:</p>
<ol>
<li><p>地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间</p>
</li>
<li><p>资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源</p>
</li>
<li><p>线程是处理器调度的基本单位,但进程不是</p>
</li>
<li><p>二者均可并发执行</p>
</li>
<li><p>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制</p>
</li>
</ol>
<p><strong>协程多与线程进行比较”</strong></p>
<ol>
<li><p>一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。</p>
</li>
<li><p>线程进程都是同步机制，而协程则是异步</p>
</li>
<li><p>协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态</p>
</li>
<li>TCP的滑动窗口</li>
<li>为什么要三次握手</li>
<li>为什么要用虚函数</li>
<li>介绍一下STL</li>
<li>说说c++11的新特性<ul>
<li><a href="https://blog.csdn.net/FX677588/article/details/70157088" target="_blank" rel="noopener">https://blog.csdn.net/FX677588/article/details/70157088</a></li>
<li><a href="https://my.oschina.net/wangxuanyihaha/blog/183151" target="_blank" rel="noopener">https://my.oschina.net/wangxuanyihaha/blog/183151</a></li>
<li><a href="https://coolshell.cn/articles/5265.html" target="_blank" rel="noopener">https://coolshell.cn/articles/5265.html</a></li>
</ul>
</li>
<li>编程：硬币组合问题</li>
<li>编程：给出给个节点的id和其父节点的id,构建一个多叉树</li>
<li>本来想问数据库的没问</li>
</ol>
<h3 id="360面试"><a href="#360面试" class="headerlink" title="360面试"></a>360面试</h3><ol>
<li>线程的通信方式</li>
<li>构造顺序</li>
<li>析构顺序</li>
<li>sizeof(class A)</li>
<li>n+1个整数，都在1~n之间，只有一个重复，怎么做？<ul>
<li>假设第一个是k，可以和第k个换，这样循环，不用额外空间</li>
</ul>
</li>
<li>黑名单实现（域名匹配）</li>
</ol>
<h1 id="C-基础知识"><a href="#C-基础知识" class="headerlink" title="C++基础知识"></a>C++基础知识</h1><h2 id="C-内存空间"><a href="#C-内存空间" class="headerlink" title="C++内存空间"></a>C++内存空间</h2><p>一个C++程序编译以后占用的内存分为如下几个部分：<br><strong>栈：</strong>由编译器自动分配释放，存放函数的参数值，局部变量的值。在一个进程中，位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数的调用。</p>
<p><strong>堆：</strong>由程序员分配和释放，若程序员不释放，则程序结束时被操作系统回收。存放由new、malloc分配的内存，可动态扩展和收缩。</p>
<p><strong>全局区（静态区）：</strong>全局变量和静态变量是存放在一起的，初始化的全局变量和初始化的静态变量在一块区域；未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。</p>
<p><strong>文字常量区：</strong>常量字符串放在这里，程序结束后由操作系统释放。</p>
<p><strong>程序代码区：</strong>存放函数体的二进制代码。</p>
<p>###堆和栈的主要区别</p>
<ol>
<li>管理的方式不同。栈由编译器自动管理，无需手动控制；堆由程序员控制，容易产生内存泄漏。</li>
<li>能否产生碎片。对于堆来说，频繁地new/delete势必造成内存空间的不连续，从而造成大量碎片，使程序效率降低；对于栈来说，不会存在这个问题，因为栈是后进先出的队列，一一对应，不会出现某个内存块从栈中间弹出。</li>
<li>生长方向。对于堆来说，生长方向向上，向着内存地址增加的地方；对于栈，生长方向向下，向着内存地址减小的方向。</li>
<li>分配效率：栈是计算机系统提高的数据结构，操作系统在底层对栈提供支持，分配专门的寄存器存放栈的地址，压栈出栈有专门的指令执行，这就决定了栈的效率比较高。对于堆则是由C/C++函数库提供，显然栈的效率比堆高。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;                     <span class="comment">//全局初始化区</span></span><br><span class="line"><span class="keyword">char</span> *p1;                      <span class="comment">//全局未初始化区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> b;                       <span class="comment">//栈区</span></span><br><span class="line">  <span class="keyword">char</span> s[] = <span class="string">"abc"</span>;            <span class="comment">//栈区</span></span><br><span class="line">  <span class="keyword">char</span> *p2;                    <span class="comment">//栈区</span></span><br><span class="line">  <span class="keyword">char</span> *p3 = <span class="string">"123456"</span>;         <span class="comment">//123456在常量区，指针p3在栈上。</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> c =<span class="number">0</span>；            <span class="comment">//全局（静态）初始化区</span></span><br><span class="line">  p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">  p2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">  <span class="comment">//分配得来得10和20字节的区域就在堆区。</span></span><br><span class="line">  <span class="built_in">strcpy</span>(p1, <span class="string">"123456"</span>);      </span><br><span class="line">  <span class="comment">//123456放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="C-复习记录"><a href="#C-复习记录" class="headerlink" title="C++复习记录"></a>C++复习记录</h2><ol>
<li><p>静态局部变量的作用：保存函数每次执行后的结果，以便下次调用函数时，继续使用上次计算的结果。</p>
</li>
<li><p>宏定义可出现在程序中的任何一行。</p>
</li>
<li><p>宏的作用域：从定义开始到文件结束，或者使用<code>#undef</code>指令终止宏。如果在此区间有包含文件<code>#include</code>指令，那么宏作用域会延伸到被包含的整个文件。</p>
</li>
<li><p>宏定义无须分号结尾，但是如果有不报错。</p>
</li>
<li><p>如果字符串中出现宏名，则不进行宏展开。</p>
</li>
<li><p>有参宏：<code>#define &lt;宏名&gt;(&lt;形参表&gt;) &lt;含形参的字符串&gt;</code></p>
</li>
<li><p>条件编译：</p>
<ul>
<li><p>宏名作为条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef &lt;宏名&gt; </span><br><span class="line">    &lt;程序段&gt;</span><br><span class="line">#else</span><br><span class="line">    &lt;程序段&gt;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
</li>
<li><p>常量表达式作为条件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if &lt;常量表达式&gt; </span><br><span class="line">    &lt;程序段&gt;</span><br><span class="line">#elif &lt;常量表达式&gt;</span><br><span class="line">    &lt;程序段&gt;</span><br><span class="line">#else</span><br><span class="line">    &lt;程序段&gt;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>结构体中的静态变量的值为该结构类型的所有变量共享，访问的时候使用<code>::</code>。</p>
</li>
<li>所有枚举类型的大小都是4字节，即一个int值的大小。</li>
<li><p><code>typedef char str[10];</code>以这种方式给<code>char[10]</code>起别名。</p>
</li>
<li><p><code>const</code>:</p>
<ul>
<li><code>const *</code>：指针指向的内容不能变。</li>
<li><code>* const</code>：指针不能变</li>
<li><code>const * const</code>：都不能变，而且需要初始化</li>
</ul>
</li>
<li><code>new</code>和<code>delete</code>成对使用，<code>delete []&lt;指针变量&gt;</code>：吧所执行的数组元素的内存空间归还。</li>
<li>类的保护成员被自己类的成员函数访问，也能被自己的<strong>派生类</strong>访问。</li>
<li>一个类的对象不能作为自身类的成员，但是自身类的指针可以作为该类的成员。</li>
<li>类不允许对数据成员进行初始化，必须使用构造函数。</li>
<li>类和结构体的区别：<ul>
<li>c++中结构体也可以使用<code>private</code>等关键字</li>
<li>类成员的默认访问权限为<code>private</code>，而结构体成员的默认访问权限为<code>public</code></li>
<li>结构体可以使用花括号进行初始化，但是类只能使用构造函数。</li>
<li>结构体也可以构造函数</li>
</ul>
</li>
<li>如果一个构造函数没有任何形参，或者所有形参都有默认值，这就是一个默认构造函数。</li>
<li>拷贝构造函数：<code>&lt;类名&gt;::&lt;类名&gt;(const &lt;类名&gt; &amp;&lt;对象名&gt;)</code></li>
<li><p><strong>如果一个类中显式的定义了一个拷贝构造函数，而没有其他构造函数，则该类不能创建对象。</strong></p>
</li>
<li><p>用sizeof（类名）得到的大小不包括静态成员。静态成员函数主要用于管理类中的静态数据成员，不能直接访问非静态成员，不能定义为虚函数。</p>
</li>
<li><p>静态成员函数可以被继承，但不能定义为虚函数。</p>
</li>
<li>数据成员的指针：<code>&lt;type&gt;&lt;class name&gt;::*&lt;point name&gt; = &amp;&lt;class name&gt;::&lt;class member name&gt;</code></li>
<li><p>多态：</p>
<ul>
<li>编译时刻的静态多态性：函数重载和运算符重载</li>
<li>运行时刻的动态多态性：继承和虚函数</li>
</ul>
</li>
<li><p>虚基类是为了防止二义性，继承方式为在：之后加上virtual，只能产生一个子对象。</p>
</li>
<li>若不使用虚函数，则调用函数时，是由指针类型决定的；反之是由对象的实际类型决定的。</li>
<li><p>如果一个类含有纯虚函数，那么此类就称为抽象类（接口）。</p>
<p><code>virtual &lt;返回类型&gt; name (&lt;形参表&gt;) = 0</code></p>
</li>
<li>运算符重载：形参数比运算符目数少一个</li>
<li><p>友元函数：将类外函数用<code>friend</code>修饰，可以访问类内所有成员。</p>
</li>
<li><p>虚函数不能是静态成员函数，也不能是友元函数。</p>
</li>
<li><p>二级指针可以用来访问二维数组，但不能直接指向一个二维数组。</p>
</li>
<li><p>模板与有参宏的区别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(x,y) ((x)&lt;(y))?(x):(y)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>宏展开时编译器不能检查类型兼容性</li>
<li>若<code>cout&lt;&lt;max(x,++y)</code>，则y会计算两次</li>
<li>宏扩展属于预处理，编译是针对宏扩展之后的代码进行，编译错误只能给出宏扩展之后的代码错误，而不是宏定义自身的错误。</li>
</ul>
</li>
<li><p>重载类型转换函数：<code>operator type()</code></p>
</li>
<li><p>RTTI：运行时类型信息，<code>typeid(&lt;表达式&gt;).name()</code> </p>
</li>
<li><p>explicit 可以有效得防止构造函数的隐式转换带来的错误或者误解<br><a href="https://www.cnblogs.com/cutepig/archive/2009/01/14/1375917.html" target="_blank" rel="noopener">https://www.cnblogs.com/cutepig/archive/2009/01/14/1375917.html</a></p>
</li>
</ol>
<h2 id="C-string的用法和例子"><a href="#C-string的用法和例子" class="headerlink" title="C++ string的用法和例子"></a>C++ string的用法和例子</h2><h3 id="使用场合："><a href="#使用场合：" class="headerlink" title="使用场合："></a>使用场合：</h3><p>string 是 C++ 标准库的一个重要的部分，主要用于字符串处理。可以使用输入输出流方式直接进行操作，也可以通过文件等手段进行操作。同时 C++ 的算法库对 string 也有着很好的支持，而且 string 还和 c 语言的字符串之间有着良好的接口。虽然也有一些弊端，但是瑕不掩瑜。<br>其中使用的代码多数都是来自 cpp 官网，因为例子非常全。</p>
<h3 id="声明和初始化方法："><a href="#声明和初始化方法：" class="headerlink" title="声明和初始化方法："></a><strong>声明和初始化方法：</strong></h3><p>想使用 string 首先要在头文件当中加入 <string><br>声明方式也很简单</string></p>
<h4 id="声明："><a href="#声明：" class="headerlink" title="声明："></a>声明：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s;//声明一个string 对象</span><br><span class="line">string ss[10];//声明一个string对象的数组</span><br></pre></td></tr></table></figure>
<h4 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h4><p>使用等号的初始化叫做拷贝初始化，不使用等号的初始化叫做直接初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    string s;//默认初始化，一个空字符串</span><br><span class="line">    string s1(&quot;ssss&quot;);//s1是字面值“ssss”的副本</span><br><span class="line">    string s2(s1);//s2是s1的副本</span><br><span class="line">    string s3=s2;//s3是s2的副本</span><br><span class="line">    string s4(10,&apos;c&apos;);//把s4初始化</span><br><span class="line">    string s5=&quot;hiya&quot;;//拷贝初始化</span><br><span class="line">    string s6=string(10,&apos;c&apos;);//拷贝初始化，生成一个初始化好的对象，拷贝给s6</span><br><span class="line"></span><br><span class="line">    //string s(cp,n)</span><br><span class="line">    char cs[]=&quot;12345&quot;;</span><br><span class="line">    string s7(cs,3);//复制字符串cs的前3个字符到s当中</span><br><span class="line"></span><br><span class="line">    //string s(s2,pos2)</span><br><span class="line">    string s8=&quot;asac&quot;;</span><br><span class="line">    string s9(s8,2);//从s2的第二个字符开始拷贝，不能超过s2的size</span><br><span class="line"></span><br><span class="line">    //string s(s2,pos2,len2)</span><br><span class="line">    string s10=&quot;qweqweqweq&quot;;</span><br><span class="line">    string s11(s10,3,4);//s4是s3从下标3开始4个字符的拷贝，超过s3.size出现未定义</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串处理："><a href="#字符串处理：" class="headerlink" title="字符串处理："></a><strong>字符串处理：</strong></h3><h4 id="substr-操作："><a href="#substr-操作：" class="headerlink" title="substr 操作："></a><strong>substr 操作：</strong></h4><p>注意 substr 没有迭代器作为参数的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    string s=&quot;abcdefg&quot;;</span><br><span class="line"></span><br><span class="line">    //s.substr(pos1,n)返回字符串位置为pos1后面的n个字符组成的串</span><br><span class="line">    string s2=s.substr(1,5);//bcdef</span><br><span class="line"></span><br><span class="line">    //s.substr(pos)//得到一个pos到结尾的串</span><br><span class="line">    string s3=s.substr(4);//efg</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果输入的位置超过字符的长度，会抛出一个 out_of_range 的异常</p>
<h4 id="insert-操作"><a href="#insert-操作" class="headerlink" title="insert 操作:"></a><strong>insert 操作:</strong></h4><p>代码来自 cpp 官网，经过自己的整理<br>注意用迭代器当参数和无符号数当参数的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    string str=&quot;to be question&quot;;</span><br><span class="line">    string str2=&quot;the &quot;;</span><br><span class="line">    string str3=&quot;or not to be&quot;;</span><br><span class="line">    string::iterator it;</span><br><span class="line"></span><br><span class="line">    //s.insert(pos,str)//在s的pos位置插入str</span><br><span class="line">    str.insert(6,str2);                 // to be the question</span><br><span class="line"></span><br><span class="line">    //s.insert(pos,str,a,n)在s的pos位置插入str中插入位置a到后面的n个字符</span><br><span class="line">    str.insert(6,str3,3,4);             // to be not the question</span><br><span class="line"></span><br><span class="line">    //s.insert(pos,cstr,n)//在pos位置插入cstr字符串从开始到后面的n个字符</span><br><span class="line">    str.insert(10,&quot;that is cool&quot;,8);    // to be not that is the question</span><br><span class="line"></span><br><span class="line">    //s.insert(pos,cstr)在s的pos位置插入cstr</span><br><span class="line">    str.insert(10,&quot;to be &quot;);            // to be not to be that is the question</span><br><span class="line"></span><br><span class="line">    //s.insert(pos,n,ch)在s.pos位置上面插入n个ch</span><br><span class="line">    str.insert(15,1,&apos;:&apos;);               // to be not to be: that is the question</span><br><span class="line"></span><br><span class="line">    //s.insert(s.it,ch)在s的it指向位置前面插入一个字符ch，返回新插入的位置的迭代器</span><br><span class="line">    it = str.insert(str.begin()+5,&apos;,&apos;); // to be, not to be: that is the question</span><br><span class="line"></span><br><span class="line">    //s.insert(s.it,n,ch)//在s的it所指向位置的前面插入n个ch</span><br><span class="line">    str.insert (str.end(),3,&apos;.&apos;);       // to be, not to be: that is the question...</span><br><span class="line"></span><br><span class="line">    //s.insert(it,str.ita,str.itb)在it所指向的位置的前面插入[ita,itb)的字符串</span><br><span class="line">    str.insert (it+2,str3.begin(),str3.begin()+3); // to be, or not to be: that is the question...</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="erase-操作："><a href="#erase-操作：" class="headerlink" title="erase 操作："></a><strong>erase 操作：</strong></h4><p>用来执行删除操作<br>删除操作有三种</p>
<ul>
<li>指定 pos 和 len，其中 pos 为为起始位置，pos 以及后面 len-1 个字符串都删除</li>
<li>迭代器，删除迭代器指向的字符</li>
<li>迭代器范围，删除这一范围的字符串，范围左闭右开</li>
</ul>
<p>代码来自 cpp 官网</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">  std::string str (&quot;This is an example sentence.&quot;);</span><br><span class="line">  std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line">                          // &quot;This is an example sentence.&quot;</span><br><span class="line">  str.erase (10,8);       //            ^^^^^^^^</span><br><span class="line">  //直接指定删除的字符串位置第十个后面的8个字符</span><br><span class="line">  std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line">                            // &quot;This is an sentence.&quot;</span><br><span class="line">  str.erase (str.begin()+9);//           ^</span><br><span class="line">  //删除迭代器指向的字符</span><br><span class="line">  std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line">                            // &quot;This is a sentence.&quot;</span><br><span class="line">                            //       ^^^^^</span><br><span class="line">  str.erase (str.begin()+5, str.end()-9);</span><br><span class="line">  //删除迭代器范围的字符</span><br><span class="line">  std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line">                            // &quot;This sentence.&quot;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="append-和-replace-操作"><a href="#append-和-replace-操作" class="headerlink" title="append 和 replace 操作:"></a><strong>append 和 replace 操作:</strong></h4><p>append 函数可以用来在字符串的末尾追加字符和字符串。由于 string 重载了运算符，也可以用 += 操作实现<br>repalce 顾名思义，就是替换的意思，先删除，后增加。<br>代码来自 cpp 官网，附上自己的解释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    std::string str;</span><br><span class="line">    std::string str2=&quot;Writing &quot;;</span><br><span class="line">    std::string str3=&quot;print 10 and then 5 more&quot;;</span><br><span class="line"></span><br><span class="line">    //直接追加一个str2的字符串</span><br><span class="line">    str.append(str2);                       // &quot;Writing &quot;</span><br><span class="line">    //后面追加str3第6个字符开始的3个字符串</span><br><span class="line">    str.append(str3,6,3);                   // &quot;10 &quot;</span><br><span class="line">    //追加字符串形参的前5个字符</span><br><span class="line">    str.append(&quot;dots are cool&quot;,5);          // &quot;dots &quot;</span><br><span class="line">    //直接添加</span><br><span class="line">    str.append(&quot;here: &quot;);                   // &quot;here: &quot;</span><br><span class="line">    //添加10个&apos;.&apos;</span><br><span class="line">    str.append(10u,&apos;.&apos;);                    // &quot;..........&quot;</span><br><span class="line">    //添加str3迭代器范围的字符串</span><br><span class="line">    str.append(str3.begin()+8,str3.end());  // &quot; and then 5 more&quot;</span><br><span class="line">    //最后这个比较特殊，意思是添加5个&apos;A&apos;，实际上参数里面的65对应的asc码就是65</span><br><span class="line">    str.append&lt;int&gt;(5,65);                // &quot;.....&quot;</span><br><span class="line">    //字符串追加也可以用重载运算符实现</span><br><span class="line">    str+=&quot;lalala&quot;;</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>replace 的使用方法，replace 支持使用无符号整数寻找位置，也支持用迭代器寻找位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    std::string base=&quot;this is a test string.&quot;;</span><br><span class="line">    std::string str2=&quot;n example&quot;;</span><br><span class="line">    std::string str3=&quot;sample phrase&quot;;</span><br><span class="line">    std::string str4=&quot;useful.&quot;;</span><br><span class="line"></span><br><span class="line">    // replace signatures used in the same order as described above:</span><br><span class="line"></span><br><span class="line">    // Using positions:                 0123456789*123456789*12345</span><br><span class="line">    std::string str=base;           // &quot;this is a test string.&quot;</span><br><span class="line">    //第9个字符以及后面的4个字符被str2代替</span><br><span class="line">    str.replace(9,5,str2);          // &quot;this is an example string.&quot; (1)</span><br><span class="line">    //第19个字符串以及后面的5个字符用str的第7个字符以及后面的5个字符代替</span><br><span class="line">    str.replace(19,6,str3,7,6);     // &quot;this is an example phrase.&quot; (2)</span><br><span class="line">    //第8个字符以及后面的9个字符用字符串参数代替</span><br><span class="line">    str.replace(8,10,&quot;just a&quot;);     // &quot;this is just a phrase.&quot;     (3)</span><br><span class="line">    //第8个字符以及后面的5个字符用字符串参数的前7个字符替换</span><br><span class="line">    str.replace(8,6,&quot;a shorty&quot;,7);  // &quot;this is a short phrase.&quot;    (4)</span><br><span class="line">    //第22以及后面的0个字符用3个叹号替换</span><br><span class="line">    str.replace(22,1,3,&apos;!&apos;);        // &quot;this is a short phrase!!!&quot;  (5)</span><br><span class="line">    //迭代器的原理同上</span><br><span class="line">    // Using iterators:                                               0123456789*123456789*</span><br><span class="line">    str.replace(str.begin(),str.end()-3,str3);                    // &quot;sample phrase!!!&quot;      (1)</span><br><span class="line">    str.replace(str.begin(),str.begin()+6,&quot;replace&quot;);             // &quot;replace phrase!!!&quot;     (3)</span><br><span class="line">    str.replace(str.begin()+8,str.begin()+14,&quot;is coolness&quot;,7);    // &quot;replace is cool!!!&quot;    (4)</span><br><span class="line">    str.replace(str.begin()+12,str.end()-4,4,&apos;o&apos;);                // &quot;replace is cooool!!!&quot;  (5)</span><br><span class="line">    str.replace(str.begin()+11,str.end(),str4.begin(),str4.end());// &quot;replace is useful.&quot;    (6)</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;   </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的 replace 操作可以用 insert 和 erase 的操作组合替换，但是 replace 操作更加方便。</p>
<p><strong>assign 操作：</strong><br>assign 操作在一起列容器当中都存在，比如 vector 等等。是一个很基本的操作函数，string 使用 assign 可以灵活的对其进行赋值。<br>代码来自 cpp 官网</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    std::string str;</span><br><span class="line">    std::string base=&quot;The quick brown fox jumps over a lazy dog.&quot;;</span><br><span class="line"></span><br><span class="line">    // used in the same order as described above:</span><br><span class="line">    //直接把base赋值给str</span><br><span class="line">    str.assign(base);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    //把base第10个字符以及后面的8个字符赋给str</span><br><span class="line">    str.assign(base,10,9);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;         // &quot;brown fox&quot;</span><br><span class="line">    //把参数中的0到6个字符串赋给str</span><br><span class="line">    str.assign(&quot;pangrams are cool&quot;,7);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;         // &quot;pangram&quot;</span><br><span class="line">    //直接使用参数赋值</span><br><span class="line">    str.assign(&quot;c-string&quot;);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;         // &quot;c-string&quot;</span><br><span class="line">    //给str赋值10个&apos;*&apos;字符</span><br><span class="line">    str.assign(10,&apos;*&apos;);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;         // &quot;**********&quot;</span><br><span class="line">    //赋值是10个&apos;-&apos;</span><br><span class="line">    str.assign&lt;int&gt;(10,0x2D);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;         // &quot;----------&quot;</span><br><span class="line">    //指定base迭代器范围的字符串</span><br><span class="line">    str.assign(base.begin()+16,base.end()-12);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;         // &quot;fox jumps over&quot;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="string-的搜索操作"><a href="#string-的搜索操作" class="headerlink" title="string 的搜索操作:"></a><strong>string 的搜索操作:</strong></h3><p>string 类中提供了很多性能优秀，使用方便的成员方法。而且在泛型算法当中也有很多实用的技巧。</p>
<h4 id="find-和-rfind-函数"><a href="#find-和-rfind-函数" class="headerlink" title="find 和 rfind 函数:"></a><strong>find 和 rfind 函数:</strong></h4><p>find 函数主要是查找一个字符串是否在调用的字符串中出现过，大小写敏感。<br>代码来自 cpp 官网</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    std::string str (&quot;There are two needles in this haystack with needles.&quot;);</span><br><span class="line">    std::string str2 (&quot;needle&quot;);</span><br><span class="line"></span><br><span class="line">    // different member versions of find in the same order as above:</span><br><span class="line">    //在str当中查找第一个出现的needle，找到则返回出现的位置，否则返回结尾</span><br><span class="line">    std::size_t found = str.find(str2);</span><br><span class="line">    if (found!=std::string::npos)</span><br><span class="line">    std::cout &lt;&lt; &quot;first &apos;needle&apos; found at: &quot; &lt;&lt; found &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    //在str当中，从第found+1的位置开始查找参数字符串的前6个字符</span><br><span class="line">    found=str.find(&quot;needles are small&quot;,found+1,6);</span><br><span class="line">    if (found!=std::string::npos)</span><br><span class="line">    std::cout &lt;&lt; &quot;second &apos;needle&apos; found at: &quot; &lt;&lt; found &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    //在str当中查找参数中的字符串</span><br><span class="line">    found=str.find(&quot;haystack&quot;);</span><br><span class="line">    if (found!=std::string::npos)</span><br><span class="line">    std::cout &lt;&lt; &quot;&apos;haystack&apos; also found at: &quot; &lt;&lt; found &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    //查找一个字符</span><br><span class="line">    found=str.find(&apos;.&apos;);</span><br><span class="line">    if (found!=std::string::npos)</span><br><span class="line">    std::cout &lt;&lt; &quot;Period found at: &quot; &lt;&lt; found &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    //组合使用，把str2用参数表中的字符串代替</span><br><span class="line">    // let&apos;s replace the first needle:</span><br><span class="line">    str.replace(str.find(str2),str2.length(),&quot;preposition&quot;);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rfind 函数就是找最后一个出现的匹配字符串，返回的位置仍然是从前往后数的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    std::string str (&quot;The sixth sick sheik&apos;s sixth sheep&apos;s sick.&quot;);</span><br><span class="line">    std::string key (&quot;sixth&quot;);//                    ^</span><br><span class="line">    //rfind是找最后一个出现的匹配字符串</span><br><span class="line">    std::size_t found = str.rfind(key);</span><br><span class="line">    if (found!=std::string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;found&lt;&lt;endl;//输出23</span><br><span class="line">        str.replace (found,key.length(),&quot;seventh&quot;);//找到的sixth替换成seventh</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找的效率非常高，我没看过 stl 源码剖析，但是感觉是用 kmp 实现的。呵呵，可以自己写一个。</p>
<h4 id="find-…-of-函数"><a href="#find-…-of-函数" class="headerlink" title="find_….of 函数:"></a><strong>find_….of 函数:</strong></h4><ul>
<li>find_first_of(args) <strong>查找 args 中任何一个字符第一次出现的位置</strong></li>
<li>find_last_of(args) <strong>最后一个出现的位置</strong></li>
<li>find_fist_not_of(args) <strong>查找第一个不在 args 中的字符</strong></li>
<li>find_last_not_of <strong>查找最后一个不在 args 中出现的字符</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    std::string str1 (&quot;Please, replace the vowels in this sentence by asterisks.&quot;);</span><br><span class="line">    std::size_t found1 = str1.find_first_of(&quot;aeiou&quot;);</span><br><span class="line">    //把所有元音找出来用*代替</span><br><span class="line">    while (found1!=std::string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        str1[found1]=&apos;*&apos;;</span><br><span class="line">        found1=str1.find_first_of(&quot;aeiou&quot;,found1+1);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; str1 &lt;&lt; &apos;\n&apos;;</span><br><span class="line"></span><br><span class="line">    //在str2中找到第一个不是消协英文字母和空格的字符</span><br><span class="line">    std::string str2 (&quot;look for non-alphabetic characters...&quot;);</span><br><span class="line">    std::size_t found2 = str2.find_first_not_of(&quot;abcdefghijklmnopqrstuvwxyz &quot;);</span><br><span class="line">    if (found2!=std::string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;The first non-alphabetic character is &quot; &lt;&lt; str2[found2];</span><br><span class="line">        std::cout &lt;&lt; &quot; at position &quot; &lt;&lt; found2 &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>find_last_of 和 find_last_not_of 与 first 基本相同，就不写例子代码了。</p>
<h3 id="比较与转换"><a href="#比较与转换" class="headerlink" title="比较与转换:"></a><strong>比较与转换:</strong></h3><p>类似 c 语言的字符串比较函数 strcmp 函数一样，支持字符串比较操作，同时也类似 python、C# 语言中的函数一样，支持把数字和字符串转换。有些特性是 C++11 当中才有。<br><strong><em>注意编译器 bug：</em></strong><br>在 MinGW 编译器当中如果版本低于 3.8，虽然支持 c++11 但是里面有一个 bug，就是不支持字符串和数组的转换！要更新 MinGW 的版本才可以，或者直接使用 g++。</p>
<h4 id="compare-函数"><a href="#compare-函数" class="headerlink" title="compare 函数:"></a><strong>compare 函数:</strong></h4><p>和 strcmp 函数一样，如果两个字符串相等，那么返回 0，调用对象大于参数返回 1，小于返回 - 1。<br>在 compare 当中还支持部分比较，里面有 6 个参数可以设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    string s1=&quot;123&quot;,s2=&quot;123&quot;;</span><br><span class="line">    cout&lt;&lt;s1.compare(s2)&lt;&lt;endl;//0</span><br><span class="line"></span><br><span class="line">    s1=&quot;123&quot;,s2=&quot;1234&quot;;</span><br><span class="line">    cout&lt;&lt;s1.compare(s2)&lt;&lt;endl;//-1</span><br><span class="line"></span><br><span class="line">    s1=&quot;1234&quot;,s2=&quot;123&quot;;</span><br><span class="line">    cout&lt;&lt;s1.compare(s2)&lt;&lt;endl;//1</span><br><span class="line"></span><br><span class="line">    std::string str1 (&quot;green apple&quot;);</span><br><span class="line">    std::string str2 (&quot;red apple&quot;);</span><br><span class="line"></span><br><span class="line">    if (str1.compare(str2) != 0)</span><br><span class="line">    std::cout &lt;&lt; str1 &lt;&lt; &quot; is not &quot; &lt;&lt; str2 &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    //str1的第6个字符以及后面的4个字符和参数比较</span><br><span class="line">    if (str1.compare(6,5,&quot;apple&quot;) == 0)</span><br><span class="line">    std::cout &lt;&lt; &quot;still, &quot; &lt;&lt; str1 &lt;&lt; &quot; is an apple\n&quot;;</span><br><span class="line"></span><br><span class="line">    if (str2.compare(str2.size()-5,5,&quot;apple&quot;) == 0)</span><br><span class="line">    std::cout &lt;&lt; &quot;and &quot; &lt;&lt; str2 &lt;&lt; &quot; is also an apple\n&quot;;</span><br><span class="line">    //str1的第6个字符以及后面的4个字符和str2的第4个字符以及后面的4个字符比较</span><br><span class="line">    if (str1.compare(6,5,str2,4,5) == 0)</span><br><span class="line">    std::cout &lt;&lt; &quot;therefore, both are apples\n&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 string 重载了运算符，可以直接用 &gt;,&lt;，== 来进行比较，也很方便。</p>
<h4 id="数值转换："><a href="#数值转换：" class="headerlink" title="数值转换："></a><strong>数值转换：</strong></h4><p>在 io 的部分有过数值和字符串相互转换的例子，使用的是 stringstream 函数，在 c++11 当中有定义好的现成的函数取调用，非常方便。</p>
<table>
<thead>
<tr>
<th>string 和数值转换</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td>to_string(val)</td>
<td style="text-align:center">把 val 转换成 string</td>
</tr>
<tr>
<td>stoi(s,p,b)</td>
<td style="text-align:center">把字符串 s 从 p 开始转换成 b 进制的 int</td>
</tr>
<tr>
<td>stol(s,p,b)</td>
<td style="text-align:center">long</td>
</tr>
<tr>
<td>stoul(s,p,b)</td>
<td style="text-align:center">unsigned long</td>
</tr>
<tr>
<td>stoll(s,p,b)</td>
<td style="text-align:center">long long</td>
</tr>
<tr>
<td>stoull(s,p,b)</td>
<td style="text-align:center">unsigned long long</td>
</tr>
<tr>
<td>stof(s,p)</td>
<td style="text-align:center">float</td>
</tr>
<tr>
<td>stod(s,p)</td>
<td style="text-align:center">double</td>
</tr>
<tr>
<td>stold(s,p)</td>
<td style="text-align:center">long double</td>
</tr>
</tbody>
</table>
<p>// 注意，下段代码在 MinGw 中会报错！即使使用 c++11 编译也一样，无法识别 to_string！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    string s1;</span><br><span class="line">    s1=to_string(100);</span><br><span class="line">    cout&lt;&lt;s1&lt;&lt;endl;</span><br><span class="line">    int a=stoi(s1,0,10)+1;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><ul>
<li>解决hash冲突的几种方式</li>
<li><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="TCP-IP-网络编程-——-理论基础"><a href="#TCP-IP-网络编程-——-理论基础" class="headerlink" title="TCP/IP 网络编程 —— 理论基础"></a>TCP/IP 网络编程 —— 理论基础</h2></li>
</ul>
<h3 id="1、OSI-模型"><a href="#1、OSI-模型" class="headerlink" title="1、OSI 模型"></a>1、OSI 模型</h3><p><img src="http://omwiezyrk.bkt.clouddn.com/blog/20180807/220059792.png" alt="mark"></p>
<h3 id="2、TCP-IP-协议的四个层次"><a href="#2、TCP-IP-协议的四个层次" class="headerlink" title="2、TCP/IP 协议的四个层次"></a>2、TCP/IP 协议的四个层次</h3><p>TCP/IP 协议的体系结构分为四层，这四层由高到低分别是：应用层、传输层、网络层（网际层）和链路层（网络接口层）。<br><img src="http://omwiezyrk.bkt.clouddn.com/blog/20180807/220153555.png" alt="mark"></p>
<p>（1）链路层</p>
<p>链路层在 TCP/IP 协议栈的最低层，也称为数据链路层或网络接口层，通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。链路层的功能是把接收到的网络层数据报 (也称 IP 数据报) 通过该层的物理接口发送到传输介质上，或从物理网络上接收数据帧，抽出 IP 数据报并交给 IP 层。 </p>
<p>（2）网络层 (Network Layer)<br>网络层也称为互联网层，由于该层的主要协议是 IP 协议，因而也可简称为 IP 层。它是 TCP/IP 协议栈中最重要的一层，主要功能是可以把源主机上的分组发送到互联网中的任何一台目标主机上。</p>
<p>（3）传输层 (Transport Layer)<br>我们通常所说的两台主机之间的通信其实是两台主机上对应应用程序之间的通信，传输层提供的就是应用程序之间的通信，也叫端到端 (End to End) 的通信。在 TCP/IP 协议族中传输层包含两个不同的传输协议：一个是 TCP(传输控制协议)；另一个是 UDP(用户数据报协议)。<br>（4）应用层 (Application Layer)<br>应用层向使用网络的用户提供特定的、常用的应用程序，如使用最广泛的远程登录 (Telnet)、文件传输协议(FTP)、超文本传输协议(HTTP)、域名系统(DNS)、简单网络管理协议(SNMP) 和简单邮件传输协议 (SMTP) 等。要注意有些应用层协议是基于 TCP 协议的(如 FTP 和 HTTP 等)，有些应用层协议是基于 UDP 协议的(如 SNMP 等)。</p>
<p>TCP/IP 协议分为四层结构，这四层结构中有两个重要的边界：一个是将操作系统与应用程序分开的边界，另一个是将高层互联网地址与低层物理网卡地址分开的边界。</p>
<p><img src="http://omwiezyrk.bkt.clouddn.com/blog/20180807/220202073.png" alt="mark"></p>
<ul>
<li>操作系统边界</li>
</ul>
<p>操作系统边界的上面是应用层，应用层处理的是用户应用程序 (用户进程) 的细节问题，提供面向用户的服务。 </p>
<ul>
<li>地址边界</li>
</ul>
<p>地址边界的上层为网络层，网络层用于对不同的网络进行互联，连接在一起的所有网络为了能互相寻址，要使用统一的互联网地址 (IP 地址)。 </p>
<p>3、通信模型<br><img src="http://omwiezyrk.bkt.clouddn.com/blog/20180807/220213241.png" alt="mark"></p>
<p>4、数据封装与解封过程<br><img src="http://omwiezyrk.bkt.clouddn.com/blog/20180807/220218822.png" alt="mark"></p>
<h3 id="传输层协议TCP和UDP"><a href="#传输层协议TCP和UDP" class="headerlink" title="传输层协议TCP和UDP"></a>传输层协议TCP和UDP</h3><p>这里只讨论使用TCP协议的网络编程，由于UDP的不可靠性，现在使用的越来越少，但是为了和TCP做对比，这里还是稍微提一下概念。</p>
<h4 id="用户数据报协议（UDP）"><a href="#用户数据报协议（UDP）" class="headerlink" title="用户数据报协议（UDP）"></a>用户数据报协议（UDP）</h4><p>UDP是一个简单的、无连接、不可靠的传输层协议，应用进程往一个UDP套接字写入一个消息，该消息随后被封装到一个UDP数据报，该UDP数据报进而被封装到一个IP数据报，然后发完目的地。UDP不保证UDP数据报会到达最终目的地，不保证各个数据报达到目的地的先后顺序，也不保证每个数据报只到达一次。<br>​ 每个UDP数据报后有一个长度，在数据报正确到达目的地后，长度会随数据传递给应用程序，所以通常情况下在应用程序看来，UDP每次接收到的都是与发送的大小一致的数据包，而TCP是一个字节流协议，传输的数据是没有边界的。</p>
<p>​ 下图显示的是UDP的首部，从中可以看出，UDP其实就是在IP的基础上多提供的了一个端口，可以实现通过端口来将数据传送给特定的进程。</p>
<h4 id="传输控制协议（TCP）"><a href="#传输控制协议（TCP）" class="headerlink" title="传输控制协议（TCP）"></a>传输控制协议（TCP）</h4><p>TCP提供了面向连接的，靠性的服务，与UDP相比，它具有确认、超时重传、流量控制、拥塞控制等机制。</p>
<p>在两端进行通信前必须先建立连接，当TCP向另一端发送数据时，将启动一个定时器，它要求对端返回一个确认，如果在定时器超时后还没有收到确认，TCP就自动重传数据并等待更长时间。在数次重传失败后TCP才放弃。<br>​ 当TCP接收到另一端TCP发来的数据后，将发送一个确认，这个确认不一定是立即发送的，通常将在推迟一段时候后发送（延时确认机制）。</p>
<p>​ TCP将保持她首部和数据的校验和，这是一个端到端的校验和，目的是检验数据在传输过程中的任何变化，如果收到端的校验和有差错，TCP将丢弃这个报文段并发送确认，等待发送端超时重传。</p>
<p>​ TCP并不保证数据一定会被对端接收,因为这是不可能做到的,如果有可能，TCP就将数据递送到对端，否则就通知用户。因此，TCP也不能被描述成是100%可靠的协议，它提供的是数据的可靠递送货故障的可靠通知。</p>
<p>​ TCP含有用于动态估算客户和服务器之间的往返时间(round-trip time, RTT)的算法,以便它知道等待一个确认需要多长时间。</p>
<p>​ TCP通过给其中的每个字节关联一个序列号对所发送的数据进行排序。若接收端接收到的数据非顺序到达,接收端TCP将先根据它们的序列化重新排序，再把结果数据传递给接收应用。若接收到了重复数据，它将根据序列号判定数据是重复的,从而丢弃重复数据。</p>
<p>​ TCP总是告知对端在任何时刻它一次能够从对端接收多少字节的数据,这称为通知窗口，在任何时刻，该窗口指出接收缓冲区当前可用的空间量,从而确保发送端发送的数据不会使接收缓冲区溢出。</p>
<h5 id="TCP服务端编程的一般步骤为："><a href="#TCP服务端编程的一般步骤为：" class="headerlink" title="TCP服务端编程的一般步骤为："></a>TCP服务端编程的一般步骤为：</h5><ol>
<li>调用socket函数，创建一个套接字描述符。</li>
<li>创建网络地址结构，指定要监听的IP和端口号。</li>
<li>调用bind函数，将套接字描述符与网络地址结构绑定。</li>
<li>调用listen函数，将套接字描述符转为监听套接字，表示该描述符是用于从指定地址和端口接收连接的。</li>
<li>调用accept函数来获取链接。</li>
<li>得到连接后使用read和write函数完描述符里读写数据。</li>
<li>完成后调用close关闭描述符。</li>
</ol>
<h5 id="TCP客户端端编程的一般步骤为："><a href="#TCP客户端端编程的一般步骤为：" class="headerlink" title="TCP客户端端编程的一般步骤为："></a>TCP客户端端编程的一般步骤为：</h5><ol>
<li>调用socket函数，创建一个套接字描述符。</li>
<li>创建网络地址结构，指定要连接的服务端的IP和端口号。</li>
<li>调用connect函数连接服务端。</li>
<li>连接成功后调用read、write函数读写数据</li>
<li>完成后调用close关闭描述符。</li>
</ol>
<h1 id="其他问题汇总"><a href="#其他问题汇总" class="headerlink" title="其他问题汇总"></a>其他问题汇总</h1><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一陪。具体来说，红黑树是满足如下条件的二叉查找树（binary search tree）：</p>
<ol>
<li>每个节点要么是红色，要么是黑色。</li>
<li>根节点必须是黑色，每个叶子节点（NIL）是黑色</li>
<li>红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）。</li>
<li>对于每个节点，从该点至null（树尾端）的任何路径，都含有相同个数的黑色节点。</li>
</ol>
<p>在树的结构发生改变时（插入或者删除操作），往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的条件。</p>
<h2 id="算法类"><a href="#算法类" class="headerlink" title="算法类"></a>算法类</h2><h3 id="生成式模型和判别式模型"><a href="#生成式模型和判别式模型" class="headerlink" title="生成式模型和判别式模型"></a><a href="https://blog.csdn.net/wolenski/article/details/7985426" target="_blank" rel="noopener">生成式模型和判别式模型</a></h3><p><img src="http://omwiezyrk.bkt.clouddn.com/blog/20180904/230338530.png" alt="mark"></p>
<h3 id="卷积的作用"><a href="#卷积的作用" class="headerlink" title="卷积的作用"></a>卷积的作用</h3><p>可以理解为一种混合信息的手段。是一个滤波器，每个卷积核都可以获得不同的信息。</p>
<p><a href="http://www.hankcs.com/ml/understanding-the-convolution-in-deep-learning.html" target="_blank" rel="noopener">理解深度学习中的卷积</a></p>
<h3 id="激活函数的作用"><a href="#激活函数的作用" class="headerlink" title="激活函数的作用"></a>激活函数的作用</h3><p>用来加入非线性因素的，解决线性模型所不能解决的问题。</p>
<ul>
<li>tanh：双切正切函数，取值范围[-1,1]</li>
<li>sigmoid：采用S形函数，取值范围[0,1]</li>
<li>ReLU：简单而粗暴，大于0的留下，否则一律为0</li>
</ul>
<h3 id="池化的功能"><a href="#池化的功能" class="headerlink" title="池化的功能"></a>池化的功能</h3><p>逐步减少输入表征的空间尺寸。特别地，池化</p>
<ul>
<li>使输入表征（特征维度）更小而易操作</li>
<li>减少网络中的参数与计算数量，从而遏制过拟合</li>
<li>增强网络对输入图像中的小变形、扭曲、平移的鲁棒性（输入里的微小扭曲不会改变池化输出——因为我们在局部邻域已经取了最大值/平均值）。</li>
<li>帮助我们获得不因尺寸而改变的等效图片表征。这非常有用，因为这样我们就可以探测到图片里的物体，不论那个物体在哪。</li>
</ul>
<h3 id="ROIPooling-和-ROIAlign"><a href="#ROIPooling-和-ROIAlign" class="headerlink" title="ROIPooling 和 ROIAlign"></a>ROIPooling 和 ROIAlign</h3><p><strong>RoI Pooling</strong></p>
<p>实现从原图ROI区域映射到卷积区域最后pooling到固定大小的功能，然后通过池化把该区域的尺寸归一化成卷积网络输入的尺寸。</p>
<p><strong>ROIAlign</strong></p>
<p>上面RoI Pooling从原图ROI映射到卷积区域，即原图ROI与特征图ROI之间的映射，使用了stride间隔的取整，使得特征图ROI再映射回原图ROI的时候有stride的误差。尤其经过最大值池化后的特征与原ROI之间的空间不对齐就更加明显了。 </p>
<p>因此，ROIAlign从原图到特征图直接的ROI映射直接使用双线性插值，不取整，这样误差会小很多，经过池化后再对应回原图的准确性也更高些。 </p>
<p>这里假设得到的浮点型坐标为(x,y)，取其周围最近的四个点，在Y方向内插两次，再在X方向内插一次，得到新的值。ROI的形状是不变化的。</p>
<h3 id="SVM的理解"><a href="#SVM的理解" class="headerlink" title="SVM的理解"></a>SVM的理解</h3><ul>
<li><p><a href="https://blog.csdn.net/v_july_v/article/details/7624837" target="_blank" rel="noopener">理解svm的三重境界</a></p>
</li>
<li><p><a href="https://my.oschina.net/wangguolongnk/blog/111349?fromerr=lMaxdRMU" target="_blank" rel="noopener">深入理解支持向量机的对偶问题</a></p>
</li>
</ul>
<h3 id="为什么要用L2-loss？"><a href="#为什么要用L2-loss？" class="headerlink" title="为什么要用L2 loss？"></a>为什么要用L2 loss？</h3><p><img src="http://omwiezyrk.bkt.clouddn.com/blog/20180904/230450534.png" alt="mark"><br><img src="http://omwiezyrk.bkt.clouddn.com/blog/20180904/230458375.png" alt="mark"></p>
<h3 id="光流场是什么"><a href="#光流场是什么" class="headerlink" title="光流场是什么"></a>光流场是什么</h3><p>光流场是图片中每个像素都有一个x方向和y方向的位移，所以在上面那些光流计算结束后得到的光流flow是个和原来图像大小相等的双通道图像。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/08/dataStucture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Doordy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://blog-1251940545-1251940545.cossh.myqcloud.com/133908722.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Heart">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/08/dataStucture/" itemprop="url">数据结构复习记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-08T00:00:00+08:00">
                2018-10-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/我们/" itemprop="url" rel="index">
                    <span itemprop="name">我们</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>地址连续的存储单元，可以随机访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType *data;</span><br><span class="line">	<span class="keyword">int</span> MaxSize, length;</span><br><span class="line">&#125;SeqList;</span><br><span class="line"><span class="comment">//这种写法是c中的，以前的代码中，声明struct新对象时，必须要带上struct，即形式为： </span></span><br><span class="line"><span class="comment">//struct 结构名 对象名</span></span><br><span class="line"><span class="comment">//c++中只需要struct 结构名&#123;结构体&#125;，声明新对象时：结构名 对象名</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	SeqList L;</span><br><span class="line">	<span class="keyword">int</span> InitSize;</span><br><span class="line">	<span class="comment">//C语言的动态分配语句</span></span><br><span class="line">	L.data = (ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType)*InitSize);</span><br><span class="line">	<span class="comment">//c++的动态分配语句</span></span><br><span class="line">	L.data = <span class="keyword">new</span> ElemType[InitSize];</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>单链表节点描述：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    LNode *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><p>栈和队列都是受限线性表，可以使用顺序存储和链式存储。</p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="1-满二叉树：树的每一层含有最多的节点"><a href="#1-满二叉树：树的每一层含有最多的节点" class="headerlink" title="1. 满二叉树：树的每一层含有最多的节点"></a>1. 满二叉树：树的每一层含有最多的节点</h3><p>高度为<code>h</code>，节点数为<code>2^h-1 = 2^0 + 2^1 + ...+ 2^(h-1)</code>，利用等差数列求和公式计算：</p>
<p><img src="http://omwiezyrk.bkt.clouddn.com/blog/20180717/210331953.png" alt="mark"></p>
<h3 id="2-完全二叉树："><a href="#2-完全二叉树：" class="headerlink" title="2. 完全二叉树："></a>2. 完全二叉树：</h3><ul>
<li>如果有度为1的节点，只可能有1个。<h3 id="3-二叉排序树："><a href="#3-二叉排序树：" class="headerlink" title="3. 二叉排序树："></a>3. 二叉排序树：</h3>左子树上所有节点的关键字均小于根节点的关键字；右子树上的所有节点的关键字均大于根节点上的关键字。左右子树又分别是一棵二叉排序树。<h3 id="4-平衡二叉树："><a href="#4-平衡二叉树：" class="headerlink" title="4. 平衡二叉树："></a>4. 平衡二叉树：</h3>树上任一节点的左子树和右子树的深度之差不超过1。</li>
</ul>
<p><strong>二叉树的性质：</strong></p>
<ul>
<li>二叉树可以为空</li>
<li><p>叶子节点数等于度为2的节点数加1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">证明：</span><br><span class="line">    N为节点数，B为分支总数。</span><br><span class="line">    N = N1 + N2 + N0</span><br><span class="line">    N = B + 1（除了根节点，其余节点都有一个分支进入）</span><br><span class="line">    B = N1 + 2 * N2</span><br><span class="line">    公式联合：N0 = N2 + 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>第K层最多有2^(k-1)个节点</p>
</li>
<li>具有N个节点的<strong>完全二叉树</strong>的高度为<code>ceil(log(N+1))</code> or <code>floor(logN) + 1</code>。</li>
</ul>
<p>二叉树的链式存储结果描述：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="comment">//这里最好初始化一下，层次遍历的时候出现了初始化不为NULL的问题</span></span><br><span class="line">    BiTNode *lchild = <span class="literal">NULL</span>, *rchild = <span class="literal">NULL</span>;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure></p>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>递归实现，以先序遍历为例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        visit(T);</span><br><span class="line">        preOrder(T-&gt;lchild);</span><br><span class="line">        preOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>时间复杂度为O(n)，空间复杂度最坏为O(n)，即为单支树。</strong></p>
<p>非递归实现，以中序遍历为例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要借助一个栈</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BiTree&gt; s;</span><br><span class="line">    BiTree p = T;</span><br><span class="line">    <span class="keyword">while</span>(p || !s.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            visit(p);</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>层次遍历，需要借助一个队列:</p>
<p>这里使用deque实现，vector在尾部之外的位置插入或者删除元素会比较慢。详见<a href="https://www.cnblogs.com/zhuyf87/archive/2012/12/09/2809896.html" target="_blank" rel="noopener">deque与vector的主要区别</a>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">	<span class="built_in">deque</span>&lt;BiTree&gt; <span class="built_in">queue</span>;</span><br><span class="line">	<span class="built_in">queue</span>.push_back(T);</span><br><span class="line">	BiTree p;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">queue</span>.empty())&#123;</span><br><span class="line">		p = <span class="built_in">queue</span>.front(); </span><br><span class="line">		<span class="built_in">queue</span>.pop_front();</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;lchild)<span class="built_in">queue</span>.push_back(p-&gt;lchild);</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;rchild)<span class="built_in">queue</span>.push_back(p-&gt;rchild);</span><br><span class="line">		visit(p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>由二叉树的先序序列和中序序列可以唯一的确定一棵二叉树</strong></p>
<p>具体实现见：<a href="https://www.jianshu.com/p/62060a257d2d" target="_blank" rel="noopener">重建二叉树</a></p>
<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>含有两个标志域，指示指针域是孩子节点还是前驱（后继）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    BiTNode *lchild = <span class="literal">NULL</span>, *rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> ltag,rtag;</span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br></pre></td></tr></table></figure></p>
<h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><ul>
<li>树的先根遍历的顺序与这颗树响应的二叉树的先序遍历顺序相同。</li>
<li>树的后根遍历的顺序与这颗树响应的二叉树的中序遍历顺序相同。</li>
</ul>
<h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><p>构造和插入：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉排序树的插入，也可以用来构造</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BST_Insert</span><span class="params">(BiTree &amp;T, ElemType k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">		T-&gt;data = k;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//返回1，代表成功</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (k &gt; T-&gt;data)&#123;</span><br><span class="line">		<span class="keyword">return</span> BST_Insert(T-&gt;lchild, k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> BST_Insert(T-&gt;rchild, k);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果对二叉排序树进行中序遍历，会得到递增的有序序列。因此删除有左、右子树的节点z时，使用z的直接后继（或者前驱）代替z，然后从二叉树中删除这个直接后继（或前驱）。</li>
<li>高度为H的二叉排序树，插入和删除的时间复杂度是<code>O(H)</code>。最坏的情况为单支树，为<code>O(N)</code>。如果是平衡二叉树，平均查找长度为<code>O(logN)</code>。</li>
</ul>
<h2 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="平衡二叉树（AVL树）"></a>平衡二叉树（AVL树）</h2><p>特殊的二叉排序树，要保证任一节点的左右子树高度差的绝对值不能超过1。</p>
<p>#图</p>
<ul>
<li>邻接矩阵：容易确定任意两个节点是否有边相连。但是要确定边的数量，需要遍历整个矩阵。稠密图适合使用邻接矩阵。</li>
<li>邻接表：存在两种节点：顶点表节点和边表节点。顶点表使用顺序存储，节点结构为<code>|data|firstarc|</code>；边表使用链表存储，节点结构为<code>|adjvex|nextarc|</code>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图的邻接矩阵存储</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MGraph</span>&#123;</span></span><br><span class="line">	VertexType vertex[MaxVertexNum];</span><br><span class="line">	EdgeType edge[MaxVertexNum][MaxVertexNum];</span><br><span class="line">	<span class="keyword">int</span> vexnum, arcnum; <span class="comment">//图的当前顶点数和弧数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图的邻接表存储</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line">	VertexType adjvex;</span><br><span class="line">	ArcNode *nextarc = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span>&#123;</span></span><br><span class="line">	VertexType data;</span><br><span class="line">	ArcNode *firstarc = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ALGraph</span>&#123;</span></span><br><span class="line">	VertexNode graph[MaxVertexNum];</span><br><span class="line">	<span class="keyword">int</span> vexnum, arcnum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>类似于二叉树树的层序遍历，不过由于图可能存在环路的原因，所以需要一个访问标记数组。</p>
<ul>
<li>使用邻接表表示的时候，时间复杂度为<code>O(V+E),V为节点的个数，E为弧的个数</code>，每个节点都需要入队一次，每条边至少访问一次，<em>结合下面代码的两个while理解</em>；</li>
<li>使用邻接矩阵表示的时候，时间复杂度为<code>O(V^2)</code>，因为查找每个节点的邻接点都需要<code>O(V)</code>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表形式的广度优先遍历</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited(MaxVertexNum, <span class="literal">false</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(LGraph G, VertexType v)</span></span>&#123;</span><br><span class="line">	<span class="built_in">deque</span>&lt;VertexType&gt; <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">	visit(v);</span><br><span class="line">	visited[v] = <span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">queue</span>.push_back(v);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">queue</span>.empty())&#123;</span><br><span class="line">		<span class="comment">//取队首元素</span></span><br><span class="line">		VertexType t = <span class="built_in">queue</span>.front();</span><br><span class="line">		<span class="built_in">queue</span>.pop_front();</span><br><span class="line"></span><br><span class="line">		ArcPoint p = G.graph[t];</span><br><span class="line">		<span class="keyword">while</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span> (!visited[p-&gt;adjvex])&#123;</span><br><span class="line">				visit(p-&gt;adjvex);</span><br><span class="line">				visited[p-&gt;adjvex] = <span class="literal">true</span>;</span><br><span class="line">				<span class="built_in">queue</span>.push_back(p-&gt;adjvex);</span><br><span class="line">			&#125;</span><br><span class="line">			p = p-&gt;nextarc;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用广度优先求解单源最短路径，因为广度优先都是按照距离出发点由近到远来遍历图中的每个顶点的，只需要增加一个距离数组，初始化为正无穷，之后根据访问顺序进行+1操作即可。</p>
<h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>类似于树的先序遍历，可以使用递归实现。时间复杂度和空间复杂度与广度优先遍历相同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(LGraph G, VertexType v)</span></span>&#123;</span><br><span class="line">	visit(v);</span><br><span class="line">	visited[v] = <span class="literal">true</span>;</span><br><span class="line">	ArcPoint p = G.graph[v];</span><br><span class="line">	<span class="keyword">while</span> (p)&#123;</span><br><span class="line">		<span class="keyword">if</span> (!visited[p-&gt;adjvex])</span><br><span class="line">			DFS(G, p-&gt;adjvex);</span><br><span class="line">		p = p-&gt;nextarc;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h2><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><ul>
<li>Prim算法：选与几何中距离最近的点。适用于边稠密的图。</li>
<li>Kruskal算法：按全职的递增次序选择边。适用于边稀疏而顶点多的图。</li>
</ul>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><blockquote>
<p><code>TODO</code></p>
</blockquote>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><ol>
<li>一般线性表的顺序查找：查找成功的平均查找长度<code>ASL=(n+1)/2</code></li>
<li>有序表的线性查找:可以中途知道查找是否成功</li>
</ol>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p><strong>时间复杂度：O(logn)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lst, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line"><span class="comment">//有序表中进行二分查找，不存在返回-1</span></span><br><span class="line">	<span class="keyword">int</span> low = <span class="number">0</span>, high = lst.size() - <span class="number">1</span>, mid;</span><br><span class="line">	<span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">		mid = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (lst[mid] == key)<span class="keyword">return</span> mid;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (lst[mid] &lt; key)low = mid + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> high = mid - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分块查找：索引顺序查找"><a href="#分块查找：索引顺序查找" class="headerlink" title="分块查找：索引顺序查找"></a>分块查找：索引顺序查找</h3><p>将查找表分为若干个子块。块内的元素可以无序，但块之间是有序的。即前一个块中的最大关键字小于下一个块中的最小关键字，建立一个索引表，每个元素含有各块的最大关键字和各块的第一个关键字的地址，索引表为有序的。</p>
<p>分块查找：在索引表中顺序或者折半查找，块内顺序查找。</p>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><blockquote>
<p><code>TODO</code></p>
</blockquote>
<h3 id="散列表（HASH）"><a href="#散列表（HASH）" class="headerlink" title="散列表（HASH）"></a>散列表（HASH）</h3><ol>
<li>散列函数：<code>Hash(key) = Addr</code></li>
<li>散列函数构造方法<ul>
<li>直接定址法:<code>H(key) = a*key+b</code></li>
<li>除留余数法:<code>H(key) = key%p</code></li>
<li>数字分析法</li>
<li>平方取中法</li>
<li>折叠法</li>
</ul>
</li>
<li>处理冲突的方法<ul>
<li>开放定址法:<code>Hi = (H(key)+di)%m(m为表长)</code><ul>
<li>线性探测法:<code>di=1,2,...,m-1</code></li>
<li>平方探测法:<code>di=1^2,-1^2,2^2,...</code></li>
<li>再散列法:冲突时使用第二个散列函数<strong>计算地址增量</strong></li>
<li>伪随机序列法</li>
</ul>
</li>
<li>拉链法：同义词形成一个链表</li>
</ul>
</li>
</ol>
<h3 id="字符串模式匹配"><a href="#字符串模式匹配" class="headerlink" title="字符串模式匹配"></a>字符串模式匹配</h3><blockquote>
<p><code>TODO</code></p>
</blockquote>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><ul>
<li>状态：有序序列<code>L[1...i-1]</code>，<code>L(i)</code>，无需序列<code>L[i+1...n]</code></li>
<li>步骤：查找位置&gt;&gt;后移&gt;&gt;插入<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序:具体操作时边查找边插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; lst)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lst.size(); i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = lst[i], j = i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; lst[j])&#123;</span><br><span class="line">			lst[j+<span class="number">1</span>] = lst[j];</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		lst[j + <span class="number">1</span>] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>性能:</strong></p>
<ul>
<li>空间复杂度：<code>O(1)</code></li>
<li>时间复杂度：<ul>
<li>最好：sorted,<code>O(n)</code>。</li>
<li>最坏：顺序相反</li>
<li>平均：<code>n^2/4</code>,<code>O(n^2)</code>。</li>
</ul>
</li>
<li>稳定性：稳定</li>
<li>顺序存储或者链式存储的线性表<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3>先查找，后插入。实际上元素的移动次数没有变，所以时间复杂度还是<code>O(n)</code>。<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3>适用于基本有序和数据量不大的排序表。</li>
</ul>
<ol>
<li>先将待排序表分割成若干个形如<code>L[i,i+d,i+2d,....,i+kd]</code>的组，分别进行直接插入排序</li>
<li>减小<code>d</code>，直到<code>d=1</code>，进行一次直接插入排序。</li>
</ol>
<p><strong>性能:</strong></p>
<ul>
<li>时间复杂度：难以计算</li>
<li>空间复杂度：<code>O(1)</code></li>
<li>不稳定</li>
<li><p>顺序存储的线性表</p>
<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; lst)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = lst.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (lst[j] &gt; lst[j + <span class="number">1</span>])&#123;</span><br><span class="line">				swap(lst[j], lst[j + <span class="number">1</span>]);</span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag)<span class="keyword">break</span>; <span class="comment">//若是未发生交换，说明已经有序</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>性能:</strong></p>
<ul>
<li>空间复杂度：<code>O(1)</code></li>
<li>时间复杂度：<ul>
<li>最好：sorted,<code>O(n)</code>。</li>
<li>最坏：顺序相反</li>
<li>平均：<code>O(n^2)</code>。</li>
</ul>
</li>
<li><p>稳定性：稳定</p>
<h3 id="快速排序-分治"><a href="#快速排序-分治" class="headerlink" title="快速排序:分治"></a>快速排序:分治</h3></li>
</ul>
<ol>
<li>选一个元素作为基准</li>
<li>通过一趟排序将带排序表分为两部分，左边小于基准，右边大于基准，基准元素位置确定</li>
<li><p>递归的对子表进行以上两步</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; lst, <span class="keyword">int</span> left ,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> low = left, high = right;	</span><br><span class="line">	<span class="comment">//Partition()划分函数</span></span><br><span class="line">	<span class="keyword">int</span> pivot=lst[low];<span class="comment">//枢轴值取当前表中第一个元素</span></span><br><span class="line">	<span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">		<span class="keyword">while</span> (high&gt;low &amp;&amp; pivot &lt;= lst[high])high--;<span class="comment">//必须有=</span></span><br><span class="line">		lst[low] = lst[high];</span><br><span class="line">		<span class="keyword">while</span> (low&lt;high &amp;&amp; pivot &gt;= lst[low])low++;</span><br><span class="line">		lst[high] = lst[low];</span><br><span class="line">	&#125;</span><br><span class="line">	lst[low] = pivot;</span><br><span class="line">	QuickSort(lst,left,low<span class="number">-1</span>);</span><br><span class="line">	QuickSort(lst,high+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>性能:</strong></p>
<ul>
<li>空间复杂度：<ul>
<li>最坏情况（基本有序或者基本逆序的时候，最大情况不对称)：<code>O(n)</code></li>
<li>平均情况：<code>O(log n)</code></li>
</ul>
</li>
<li>时间复杂度：<ul>
<li>最坏：<code>O(n^2)</code></li>
<li>平均和最好情况相当：<code>O(nlog n)</code>。</li>
</ul>
</li>
<li>稳定性：不稳定</li>
</ul>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>对于排序表<code>L[1...n]</code>，第<code>i</code>趟排序即从<code>L[i...n]</code>中选择关键字最小的元素与<code>L(i)</code>，每一趟可以确定一个元素的最终位置，这样经过<code>n-1</code>趟排序就可以使得整个排序表有序。</p>
<p><strong>性能:</strong></p>
<ul>
<li>时间复杂度：<code>O(n^2)</code></li>
<li>空间复杂度：<code>O(1)</code></li>
<li>不稳定<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3></li>
</ul>
<blockquote>
<p><code>TODO:Code，USE STL</code></p>
</blockquote>
<p><strong>性能:</strong></p>
<ul>
<li>空间复杂度：<code>O(1)</code></li>
<li>时间复杂度：建堆时间<code>O(n)</code>，时间复杂度为<code>O(nlog n)</code>。</li>
<li>稳定性：不稳定</li>
</ul>
<h2 id="2-路归并排序"><a href="#2-路归并排序" class="headerlink" title="2-路归并排序"></a>2-路归并排序</h2><p><strong>思想：</strong> 将多个有序表组合成一个新的有序表。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; lst, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B;<span class="comment">//辅助数组</span></span><br><span class="line">	<span class="keyword">int</span> i = left, j = mid+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right)&#123;</span><br><span class="line">		<span class="keyword">if</span> (lst[i] &lt;= lst[j])&#123; B.push_back(lst[i]); i++; &#125;</span><br><span class="line">		<span class="keyword">else</span>&#123; B.push_back(lst[j]); j++; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将未检测完的表复制在尾部，下面两句只会运行一句</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid)&#123; B.push_back(lst[i]); i++;	&#125;</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= right)&#123;	B.push_back(lst[j]); j++; &#125;</span><br><span class="line">	<span class="comment">//复制回lst中</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; B.size(); k++)lst[left + k] = B[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; lst, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &lt; right)&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;<span class="comment">//求待排序部分的中心</span></span><br><span class="line">		MergeSort(lst, left, mid); <span class="comment">//对左半部分递归</span></span><br><span class="line">		MergeSort(lst, mid + <span class="number">1</span>, right); <span class="comment">//对右半部分递归</span></span><br><span class="line">		Merge(lst,left,mid,right);<span class="comment">//归并</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="基数排序（可以看一下与桶排序的差别）"><a href="#基数排序（可以看一下与桶排序的差别）" class="headerlink" title="基数排序（可以看一下与桶排序的差别）"></a>基数排序（可以看一下与桶排序的差别）</h2><ul>
<li>分配：根据关键字将元素置于不同的队列中</li>
<li>收集：将各个队列首尾相接，得到新的线性表<h2 id="排序算法性能"><a href="#排序算法性能" class="headerlink" title="排序算法性能"></a>排序算法性能</h2>算法|最好|平均|最坏|空间复杂度|稳定性<br>-|-|-|-|-|-<br>直接插入排序|<code>O(n)</code>|<code>O(n^2)</code>|<code>O(n^2)</code>|<code>O(1)</code>|是<br>简单选择排序|<code>O(n^2)</code>|<code>O(n^2)</code>|<code>O(n^2)</code>|<code>O(1)</code>|否<br>希尔排序| ——|—— |—— |<code>O(1)</code>|否<br>冒泡排序|<code>O(n)</code>|<code>O(n^2)</code>|<code>O(n^2)</code>|<code>O(1)</code>|是<br>快速排序|<code>O(nlogn)</code>|<code>O(nlogn)</code>|<code>O(n^2)</code>|<code>O(logn)</code>|否<br>堆排序|<code>O(nlogn)</code>|<code>O(nlogn)</code>|<code>O(nlogn)</code>|<code>O(1)</code>|否<br>归并排序|<code>O(nlogn)</code>|<code>O(nlogn)</code>|<code>O(nlogn)</code>|<code>O(n)</code>|是<br>基数排序|——|—— |——|——|是</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/30/catBBQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Doordy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://blog-1251940545-1251940545.cossh.myqcloud.com/133908722.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Heart">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/30/catBBQ/" itemprop="url">烤肉的一些事</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-30T00:00:00+08:00">
                2018-05-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/我们/" itemprop="url" rel="index">
                    <span itemprop="name">我们</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天带我去吃烤肉了</p>
<p>烤肉很好吃~~~</p>
<p>真的蛮会选好吃的的~</p>
<p>我说“谢谢你请我吃烤肉，很好吃”</p>
<p>“是带你吃，不是请你吃”</p>
<p>“请”比较深分吗？</p>
<p>可能确实我们是不太一样吧</p>
<p>今天又说我很计较钱</p>
<p>又不知道哪里给了这种感觉</p>
<p>唉</p>
<p>也不想再反驳这个问题了</p>
<p>也不是不愿意花钱</p>
<p>可能是会给人一种吃力不讨好的感觉吧</p>
<p>也花钱</p>
<p>但是可能会预算一下</p>
<p>给了不好的感觉</p>
<p>。。。。。。</p>
<p>这两件事是差不多的</p>
<p>可能我觉得没结婚都是两个独立的经济个体吧</p>
<p>虽然不想分的那么不清，但是也不想不考虑经济</p>
<p>可能我是会预算一些东西吧</p>
<p>目前也没有经济来源</p>
<p>又不想大手大脚的花父母的钱</p>
<p>唉</p>
<p>两个人有些东西确实差的有点远</p>
<p>在某些方面</p>
<p>确实觉得健康的恋爱关系不是这样的</p>
<p>两个人从开始就走的有点不寻常了</p>
<p>也不知道怎么说了</p>
<p>现在感觉我们好频繁的不开心呀</p>
<p>总是会有很多很多的小摩擦</p>
<p>唉</p>
<p>恋爱是想和喜欢的人开心的在一起呢</p>
<p>希望我们可以好好磨合</p>
<p>能相亲相爱</p>
<p>不要遗憾</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/23/fat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Doordy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://blog-1251940545-1251940545.cossh.myqcloud.com/133908722.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Heart">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/23/fat/" itemprop="url">看这个人的肥肚子</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-23T00:00:00+08:00">
                2018-05-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/我们/" itemprop="url" rel="index">
                    <span itemprop="name">我们</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这个人的肚子上全是软软的肉~~~</p>
<p>想起了小时候摸得刺猬</p>
<p>浑身都是防备</p>
<p>肚子却很软</p>
<p><img src="http://blog-1251940545-1251940545.cossh.myqcloud.com/230428001.jpg" alt="mark"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/20/marvel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Doordy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://blog-1251940545-1251940545.cossh.myqcloud.com/133908722.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Heart">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/20/marvel/" itemprop="url">大妹砸送我的礼物~</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-20T00:00:00+08:00">
                2018-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/我们/" itemprop="url" rel="index">
                    <span itemprop="name">我们</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天520，收到了大妹砸送的礼物~</p>
<p>蚁人主题的优衣库x漫威的联名T恤</p>
<p>本来店里的这件衣服都卖光了</p>
<p>大妹子找了好久才买到的~</p>
<p>超级超级开心</p>
<p><img src="http://blog-1251940545-1251940545.cossh.myqcloud.com/225556058.jpeg" alt="mark"></p>
<p>不过她说今天好没劲，没给她想要的仪式感吧~</p>
<p>是自己有点忽略了，因为刚刚表白过就没再准备</p>
<p>想想确实她要的就是这种感觉</p>
<p>没做好吧…</p>
<p>:(</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/12/YangZhou/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Doordy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://blog-1251940545-1251940545.cossh.myqcloud.com/133908722.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Heart">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/12/YangZhou/" itemprop="url">烟花三月下扬州</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-12T00:00:00+08:00">
                2018-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/我们/" itemprop="url" rel="index">
                    <span itemprop="name">我们</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>在三月的尾巴上，和静宝宝一起去了心心念的扬州</p>
<p>这也是在一起后的第一次旅行~</p>
</blockquote>
<p>先来一张镇贴神图~哈哈哈哈哈哈<br><img src="http://blog-1251940545-1251940545.cossh.myqcloud.com/111137077.jpeg" alt="mark"><br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2018/05/12/YangZhou/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/11/first_kiss/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Doordy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://blog-1251940545-1251940545.cossh.myqcloud.com/133908722.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Heart">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/11/first_kiss/" itemprop="url">KISS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-11T00:00:00+08:00">
                2018-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/我们/" itemprop="url" rel="index">
                    <span itemprop="name">我们</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>嘿嘿~</p>
<p>今天在逸夫楼顶亲到了小宝贝~</p>
<p>哈哈哈，强行亲亲~</p>
<p>叫你还嫌弃我口水</p>
<p>像果冻一样软软的甜甜的~</p>
<p>不过亲了一下之后</p>
<p>小调皮笑眯眯的看着我</p>
<p>我一脸懵~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/10/fallinlove/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Doordy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://blog-1251940545-1251940545.cossh.myqcloud.com/133908722.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Heart">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/10/fallinlove/" itemprop="url">Fall in love</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-10T00:00:00+08:00">
                2018-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/我们/" itemprop="url" rel="index">
                    <span itemprop="name">我们</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>今天超级超级超级开心。因为最喜欢的静宝宝，答应做我女朋友啦~</p>
</blockquote>
<p><img src="http://blog-1251940545-1251940545.cossh.myqcloud.com/105325107.jpeg" alt="mark"><br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2018/05/10/fallinlove/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/09/xxxmovie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Doordy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://blog-1251940545-1251940545.cossh.myqcloud.com/133908722.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Heart">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/09/xxxmovie/" itemprop="url">这个人强迫良家妇男</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-09T00:00:00+08:00">
                2018-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/我们/" itemprop="url" rel="index">
                    <span itemprop="name">我们</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>一把鼻涕一把辛酸泪…</p>
<p>皮皮猪掰着我的头叫我看五十度灰</p>
<p>还不准我摘耳机</p>
<p>555555555555</p>
<p>我这个纯洁的良家妇男就被强迫了</p>
<p>某人还不负责</p>
<p>我不禁想问一句</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2018/05/09/xxxmovie/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/09/ToLove/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Doordy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://blog-1251940545-1251940545.cossh.myqcloud.com/133908722.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Heart">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/09/ToLove/" itemprop="url">【游戏】接受挑战吧，皮皮猪</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-09T00:00:00+08:00">
                2018-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/我们/" itemprop="url" rel="index">
                    <span itemprop="name">我们</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>游戏背景：</p>
<p>在黑暗的中世纪</p>
<p>遥远的欧罗巴大陆孕育出了一种邪恶的生物——吸血鬼……<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2018/05/09/ToLove/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://blog-1251940545-1251940545.cossh.myqcloud.com/133908722.jpg"
               alt="Mr.Doordy" />
          <p class="site-author-name" itemprop="name">Mr.Doordy</p>
           
              <p class="site-description motion-element" itemprop="description">愿待你如初，爱你入骨</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/">
                <span class="site-state-item-count">33</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Miss-Zing" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      Github
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://weibo.com/u/2493428177" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      Weibo
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.Doordy</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
